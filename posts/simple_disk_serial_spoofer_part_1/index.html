<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 | Exists4All</title>
<meta name=keywords content="Windows,,Kernel,,Driver Development,,Reverse Engineering,,Kernel,,Windows,,Spoofer,,Disk,,Serial,,Disk Serial,,Tutorial,,Static SPoofer"><meta name=description content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><meta name=author content="Exists4All"><link rel=canonical href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/><meta name=google-site-verification content="FJeEV8Eq61e0o2MnOwH64y1WgBV42wPtjOS_Z8FZl4c"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://exists4all.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://exists4all.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://exists4all.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://exists4all.github.io/apple-touch-icon.png><link rel=mask-icon href=https://exists4all.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1"><meta property="og:description" content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><meta property="og:type" content="article"><meta property="og:url" content="https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-17T07:37:04+03:30"><meta property="article:modified_time" content="2024-03-17T07:37:04+03:30"><meta property="og:site_name" content="Exists4All"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1"><meta name=twitter:description content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://exists4all.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1","item":"https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1","name":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1","description":"In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0.","keywords":["Windows,","Kernel,","Driver Development,","Reverse Engineering,","Kernel,","Windows,","Spoofer,","Disk,","Serial,","Disk Serial,","Tutorial,","Static SPoofer"],"articleBody":"Introduction In this tutorial we are going to create a static disk drive serial number spoofer. This project will be a little long and need some basic knowledge about operation systems and reverse engineering. We are going to use visual studio community, IDA and windbg and I used windows 11 enterprise.\nAnalyzing the Kernel Setting up WinDBG The first step is to find out how windows get that information. By googling you can see easily you have to use wmic commands. If you open CMD and execute the wmic diskdrive get serialnumber, you can retrieve all the disk serials. So that is logical analyzing wmic in windbg, however if you do that you will find out wmic tokenize commands and send them to the kernel and then retrieve data in a xml file and fetch from there. So for simplicity we are not going to analyze wmic. Instead we are going to access wmic command directly using C++ and use debug command to see which kernel API used to get those data.\nBut for the people who are interested in analyzing wmic i will point to a little hint to do it.First of all run your virtual OS and attach kernel debugger aka windbg to it. Break windbg and use !sym noisy command and then execute lm and finally .reload to reload all needed pdbs. Also keep it in mind to add debug filter print to your OS so you can see dbgprint data in debugger, just google it.After windbg downloaded all the necessary data open execute g command and run wmic on VM. After that execute .reload /f wmic.exe this will cause windbg download wmic pdb file so you can copy it from windbg path for pdbs and use it with ida to analyzing wmic.exe. After this we want to get in to the wmic.exe context to do that execute !process 0 0 wmic.exe keep note from you process ID and then execute .process /i YOURPROCESSID execute g command to get to the context.\nNow execute the lm command and search for WMIC in the modules list, click on it and then you can see all the functions WMIC uses. Now for exampl you can put a break point on WMIC!CExecEngine::ExecuteCommand using bp WMIC!CExecEngine::ExecuteCommand and then execute g, now use a command like diskdrive to hit break point on windbg. You can use this method alongside wmic.exe and its pdb in IDA to analyze.\nAs I mentioned before wmic will make it harder to understand how windows get disk serials, instead we are going to get those data directly ourselves by calling wmic directly with our C++ program. I used this code this code, just compile it with a static linked library and copy it alongside its pdb file to your vm. Now we want to be able to use windbg to get kernel apis, but how do we put breakpoints on it?! There are two methods one is to breakpoint onload, and the other is simply adding __debugbreak(); before the place we want to hit. I added this command immediately after main. The other method is useful when we do not have access to source code.For those who want to know how to do it the other way, just follow the instructions below.\n1. !gflag +ksl 2. sxe ld myfile.exe 3. g 4. execute your file, you will hit break point onload 5. !gflag -ksl (do not need flag after hit) But in our case we have access to source code so just add debug instruction after main and then copy .pdb and your exe to your vm, also set your source code path in windbg. After that simply execute your file on your VM, this will cause windbg to hit breakpoint, then use the .reload command to reload out program pdb. I compiled my file with UserFetch name, if you did every thing right you should see something like below:\nLoading User Symbols ..... Loading unloaded module list ....... SYMSRV: BYINDEX: 0x2D C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym UserFetch.pdb 2E5ED8B3A33C4594893DBF2981D63F982 SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pdb - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pd_ - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\file.ptr - path not found SYMSRV: RESULT: 0x80070003 SYMSRV: BYINDEX: 0x2E C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym*https://msdl.microsoft.com/download/symbols UserFetch.pdb 2E5ED8B3A33C4594893DBF2981D63F982 SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pdb - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pd_ - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\file.ptr - path not found SYMSRV: HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/UserFetch.pdb SYMSRV: HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND SYMSRV: HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/UserFetch.pd_ SYMSRV: HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND SYMSRV: HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/file.ptr SYMSRV: HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND SYMSRV: RESULT: 0x80190194 SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pdb - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pdb - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pd_ - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pd_ - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\file.ptr - path not found SYMSRV: UNC: C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\file.ptr - path not found DBGHELP: I:\\Codes\\UserFetch\\x64\\Debug\\UserFetch.pdb cached to C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\sym\\UserFetch.pdb\\2E5ED8B3A33C4594893DBF2981D63F982\\UserFetch.pdb Also you have to be able to see your source code alongside other information like below.\nFinding responsible driver that gets serials Now this part is very very important, we want to be able to go to the kernel side and continue tracing kernel APIs there. To do this we need to find syscall instructions first.To do this just execute pc and then t command respectively till you reach a syscall. After that we need to find a function that will cause dispatch from user mode to kernel mode using the SSD table which I will explain later. execute p command till you reach first if then using t to trace in to it and then use mentioned instructions.\nAfter a while you will hit DeviceIoControl which is look like below:\nntdll!NtDeviceIoControlFile: 00007ff927a23fe0 4c8bd1 mov r10,rcx 00007ff927a23fe3 b807000000 mov eax,7 00007ff927a23fe8 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (000000007ffe0308)],1 00007ff927a23ff0 7503 jne ntdll!NtDeviceIoControlFile+0x15 (00007ff927a23ff5) 00007ff927a23ff2 0f05 syscall 00007ff927a23ff4 c3 ret 00007ff927a23ff5 cd2e int 2Eh 00007ff927a23ff7 c3 ret 00007ff927a23ff8 0f1f840000000000 nop dword ptr [rax+rax] Now we have to find out which function will called in kernel side. To do this first we look into the value that will put in to the eax register which ix 0x7, now we execute following command, dd nt!KiServiceTable+0xEAXValue*0x4 L1 which in our case is dd nt!KiServiceTable+0x7*0x4 L1 and that will cause windbg return first value of table. after that windbg will return fffff801`6d0cad8c 05c38306 now the second value is the value we want and we have to use in the following instruction u KiServiceTable + (0xReturnedValue »\u003e 4) so we have to execute u KiServiceTable + (0x05c38306 »\u003e 4), after that you see instructions like below:\nnt!NtDeviceIoControlFile: fffff8016d68e5a0 4883ec68 sub rsp,68h fffff8016d68e5a4 8b8424b8000000 mov eax,dword ptr [rsp+0B8h] fffff8016d68e5ab c644245001 mov byte ptr [rsp+50h],1 fffff8016d68e5b0 89442448 mov dword ptr [rsp+48h],eax fffff8016d68e5b4 488b8424b0000000 mov rax,qword ptr [rsp+0B0h] fffff8016d68e5bc 4889442440 mov qword ptr [rsp+40h],rax fffff8016d68e5c1 8b8424a8000000 mov eax,dword ptr [rsp+0A8h] fffff8016d68e5c8 89442438 mov dword ptr [rsp+38h],eax If you want to learn more about SSDT you can read this.\nNow put a break point in there using bp nt!NtDeviceIoControlFile, and use g to hit that break point. After breakpoint hit you must confirm that you are still in our process context using !process -1 0 command and it have to be your exe file.Now after this part is a little bit tricky you might get BSOD multiple times, but you have to open the call stack tab and use t and pc command till you find out all the kernel APIs called to get disk serial. After a long trace you have to see something like below which contains all the kernel APIs used to get serialnumber.\nstorport!RaGetUnitStorageDeviceProperty storport!RaUnitStorageQueryDevicePropertyIoct1+0x36 storport!RaUnitStorageQueryPropertyIoct1+0x42 storport!RaUnitDeviceControlIrp+Ox106 storport!RaDriverDeviceControlIrp+Ox5a storport!SrbShimHookDeviceControl+0x52 nt!IofCallDriver+0x59 CLASSPNP!ClassDeviceControl+0xa47 disk!DiskDeviceControl+Oxa6 CLASSPNP!ClassDeviceControlDispatch+0x82 CLASSPNP!ClassGlobalDispatch+0x24 nt!IofCallDriver+0x59 partmgr!PmIoctlQueryProperty+Ox57 partmgr!PmFilterDeviceControl+Oxeb partmgr!PmGlobalDispatch+0x20 nt!IofCallDriver+0x59 nt!IopSynchronousServiceTail+Ox1a5 nt!IopXxxControlFile+Oxcl0 nt!NtDeviceIoControlFile+Ox56 nt!RiSystemServiceCopyEnd+0x25 ntdll!NtDeviceIoControlFile+0x14 KERNELBASE!DeviceIoControl+0x67 KERNEL32!DeviceIoControlImplementation+0x80 Now you know that storport.sys is the driver that gets that data, so first we get its pdb file to be able to analyze it with IDA.Simply use lm to list all modules and then find storport click on it and then click on browse all global symbols, that will cause windbg download the pdb file. Now copy that pdb file and paste it into your VM. and on your VM go to Local Disk (C:)\\Windows\\System32\\drivers and copy storport.sys beside its pdb and load it into IDA.\nSearch for RaGetUnitStorageDeviceProperty and decompile it using F5 key.You can see that it uses some kind of struct and puts data into an array finally and returns it if you analyze the decompiled source. To confirm this we just need a simple debug to confirm this function gets serial disks. So once more run the compiled exe file and put a breakpoint on RaGetUnitStorageDeviceProperty using bp storport!RaGetUnitStorageDeviceProperty command. Simply keep continuing till you hit the desired break point, now if you analyze the codes of this driver in IDA, you can see the final call instruction at the bottom. Using the pc command we debug the instruction to get to that call which you can see it below.\nfffff8016edd573c e8bfa9f9ff call storport!memcpy (fffff8016ed70100) fffff8016edd5741 458bc6 mov r8d,r14d fffff8016edd5744 488d542420 lea rdx,[rsp+20h] fffff8016edd5749 498bcc mov rcx,r12 fffff8016edd574c e8afa9f9ff call storport!memcpy (fffff8016ed70100) fffff8016edd5751 33c0 xor eax,eax fffff8016edd5753 458937 mov dword ptr [r15],r14d fffff8016edd5756 488b8db0000000 mov rcx,qword ptr [rbp+0B0h] fffff8016edd575d 4833cc xor rcx,rsp fffff8016edd5760 e83b9bf9ff call storport!_security_check_cookie (fffff8016ed6f2a0) fffff8016edd5765 4881c4c0010000 add rsp,1C0h By some analyzing you can find out code will keep data in [rsp+20h], simply if we chek this place on memory you see the below information there:\nLast word So we confirmed this is the function, however the used struct is still unknown. We will discuss how to find it in the next part, but we mention one of the time consuming methods here and keep the neat method for the next part.You can use dt module!* which will be dt storport!* to get all the structs that strport.sys uses and then analyze them manually. If you spend a lot of time doing reverse engineering you can confirm the struct is _RAID_UNIT_EXTENSION which will be discussed in next part.\n","wordCount":"1682","inLanguage":"en","datePublished":"2024-03-17T07:37:04+03:30","dateModified":"2024-03-17T07:37:04+03:30","author":{"@type":"Person","name":"Exists4All"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/"},"publisher":{"@type":"Organization","name":"Exists4All","logo":{"@type":"ImageObject","url":"https://exists4all.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://exists4all.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://exists4all.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://exists4all.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://exists4all.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://exists4all.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://exists4all.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1</h1><div class=post-description>In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0.</div><div class=post-meta><span title='2024-03-17 07:37:04 +0330 +0330'>March 17, 2024</span>&nbsp;·&nbsp;1682 words&nbsp;·&nbsp;Exists4All&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Simple_Disk_Serial_Spoofer_part_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this tutorial we are going to create a static disk drive serial number spoofer. This project will be a little long and need some basic knowledge about operation systems and reverse engineering. We are going to use visual studio community, IDA and windbg and I used windows 11 enterprise.</p><hr><h2 id=analyzing-the-kernel>Analyzing the Kernel<a hidden class=anchor aria-hidden=true href=#analyzing-the-kernel>#</a></h2><h3 id=setting-up-windbg>Setting up WinDBG<a hidden class=anchor aria-hidden=true href=#setting-up-windbg>#</a></h3><p>The first step is to find out how windows get that information. By googling you can see easily you have to use wmic commands. If you open CMD and execute the <strong>wmic diskdrive get serialnumber</strong>, you can retrieve all the disk serials.
So that is logical analyzing wmic in windbg, however if you do that you will find out wmic tokenize commands and send them to the kernel and then retrieve data in a xml file and fetch from there. So for simplicity we are not going to analyze wmic. Instead we are going to access wmic command directly using C++ and use debug command to see which kernel API used to get those data.</p><p>But for the people who are interested in analyzing wmic i will point to a little hint to do it.First of all run your virtual OS and attach kernel debugger aka windbg to it. Break windbg and use <strong>!sym noisy</strong> command and then execute <strong>lm</strong> and finally <strong>.reload</strong> to reload all needed pdbs. Also keep it in mind to add debug filter print to your OS so you can see dbgprint data in debugger, just google it.After windbg downloaded all the necessary data open execute <strong>g</strong> command and run wmic on VM. After that execute <strong>.reload /f wmic.exe</strong> this will cause windbg download wmic pdb file so you can copy it from windbg path for pdbs and use it with ida to analyzing wmic.exe. After this we want to get in to the wmic.exe context to do that execute <strong>!process 0 0 wmic.exe</strong> keep note from you process ID and then execute <strong>.process /i YOURPROCESSID</strong> execute <strong>g</strong> command to get to the context.</p><p>Now execute the <strong>lm</strong> command and search for WMIC in the modules list, click on it and then you can see all the functions WMIC uses. Now for exampl you can put a break point on <strong>WMIC!CExecEngine::ExecuteCommand</strong> using <strong>bp WMIC!CExecEngine::ExecuteCommand</strong> and then execute <strong>g</strong>, now use a command like <strong>diskdrive</strong> to hit break point on windbg.
You can use this method alongside wmic.exe and its pdb in IDA to analyze.</p><p>As I mentioned before wmic will make it harder to understand how windows get disk serials, instead we are going to get those data directly ourselves by calling wmic directly with our C++ program. I used this code <a href=https://gist.github.com/micjabbour/a2fbe50160862e6abe439c0b0769c3fb>this code</a>, just compile it with a static linked library and copy it alongside its pdb file to your vm. Now we want to be able to use windbg to get kernel apis, but how do we put breakpoints on it?! There are two methods one is to breakpoint onload, and the other is simply adding <strong>__debugbreak();</strong> before the place we want to hit. I added this command immediately after main. The other method is useful when we do not have access to source code.For those who want to know how to do it the other way, just follow the instructions below.</p><pre tabindex=0><code>1. !gflag +ksl
2. sxe ld myfile.exe
3. g
4. execute your file, you will hit break point onload
5. !gflag -ksl (do not need flag after hit)
</code></pre><p>But in our case we have access to source code so just add debug instruction after main and then copy .pdb and your exe to your vm, also set your source code path in windbg. After that simply execute your file on your VM, this will cause windbg to hit breakpoint, then use the <strong>.reload</strong> command to reload out program pdb. I compiled my file with <strong>UserFetch</strong> name, if you did every thing right you should see something like below:</p><pre tabindex=0><code>Loading User Symbols
.....
Loading unloaded module list
.......
SYMSRV:  BYINDEX: 0x2D
C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym
UserFetch.pdb
2E5ED8B3A33C4594893DBF2981D63F982
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pdb - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pd_ - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\file.ptr - path not found
SYMSRV:  RESULT: 0x80070003
SYMSRV:  BYINDEX: 0x2E
C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym*https://msdl.microsoft.com/download/symbols
UserFetch.pdb
2E5ED8B3A33C4594893DBF2981D63F982
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pdb - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pd_ - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\file.ptr - path not found
SYMSRV:  HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/UserFetch.pdb
SYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND
SYMSRV:  HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/UserFetch.pd_
SYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND
SYMSRV:  HTTPGET: /download/symbols/UserFetch.pdb/2E5ED8B3A33C4594893DBF2981D63F982/file.ptr
SYMSRV:  HttpQueryInfo: 80190194 - HTTP_STATUS_NOT_FOUND
SYMSRV:  RESULT: 0x80190194
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pdb - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pdb - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pd_ - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pd_ - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\file.ptr - path not found
SYMSRV:  UNC: C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\file.ptr - path not found
DBGHELP: I:\Codes\UserFetch\x64\Debug\UserFetch.pdb cached to C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\sym\UserFetch.pdb\2E5ED8B3A33C4594893DBF2981D63F982\UserFetch.pdb
</code></pre><p>Also you have to be able to see your source code alongside other information like below.</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_1/LoadSelfPDB.jpg alt=Image_1></p><h3 id=finding-responsible-driver-that-gets-serials>Finding responsible driver that gets serials<a hidden class=anchor aria-hidden=true href=#finding-responsible-driver-that-gets-serials>#</a></h3><p>Now this part is very very important, we want to be able to go to the kernel side and continue tracing kernel APIs there. To do this we need to find <strong>syscall</strong> instructions first.To do this just execute <strong>pc</strong> and then <strong>t</strong> command respectively till you reach a syscall.
After that we need to find a function that will cause dispatch from user mode to kernel mode using the <strong>SSD table</strong> which I will explain later. execute <strong>p</strong> command till you reach first <strong>if</strong> then using <strong>t</strong> to trace in to it and then use mentioned instructions.</p><p>After a while you will hit <strong>DeviceIoControl</strong> which is look like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>ntdll</span><span class=p>!</span><span class=no>NtDeviceIoControlFile</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23fe0</span> <span class=mi>4</span><span class=no>c8bd1</span>          <span class=no>mov</span>     <span class=no>r10</span><span class=p>,</span><span class=no>rcx</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23fe3</span> <span class=no>b807000000</span>      <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span><span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23fe8</span> <span class=no>f604250803fe7f01</span> <span class=no>test</span>    <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>SharedUserData</span><span class=err>+</span><span class=mi>0x308</span> <span class=p>(</span><span class=mi>000000007</span><span class=no>ffe0308</span><span class=p>)],</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff0</span> <span class=mi>7503</span>            <span class=no>jne</span>     <span class=no>ntdll</span><span class=p>!</span><span class=no>NtDeviceIoControlFile</span><span class=err>+</span><span class=mi>0x15</span> <span class=p>(</span><span class=mi>00007</span><span class=no>ff927a23ff5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff2</span> <span class=mi>0</span><span class=no>f05</span>            <span class=no>syscall</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff4</span> <span class=no>c3</span>              <span class=no>ret</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff5</span> <span class=no>cd2e</span>            <span class=no>int</span>     <span class=mi>2</span><span class=no>Eh</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff7</span> <span class=no>c3</span>              <span class=no>ret</span>
</span></span><span class=line><span class=cl><span class=err>00007</span><span class=nf>ff927a23ff8</span> <span class=mi>0</span><span class=no>f1f840000000000</span> <span class=no>nop</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=p>]</span>
</span></span></code></pre></div><p>Now we have to find out which function will called in kernel side. To do this first we look into the value that will put in to the eax register which ix <strong>0x7</strong>, now we execute following command, <strong>dd nt!KiServiceTable+0xEAXValue*0x4 L1</strong> which in our case is <strong>dd nt!KiServiceTable+0x7*0x4 L1</strong> and that will cause windbg return first value of table.
after that windbg will return <strong>fffff801`6d0cad8c 05c38306</strong> now the second value is the value we want and we have to use in the following instruction
<strong>u KiServiceTable + (0xReturnedValue &#187;> 4)</strong> so we have to execute <strong>u KiServiceTable + (0x05c38306 &#187;> 4)</strong>, after that you see instructions like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>nt</span><span class=p>!</span><span class=no>NtDeviceIoControlFile</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5a0</span> <span class=mi>4883</span><span class=no>ec68</span>        <span class=no>sub</span>     <span class=no>rsp</span><span class=p>,</span><span class=mi>68</span><span class=no>h</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5a4</span> <span class=mi>8</span><span class=no>b8424b8000000</span>  <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>B8h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5ab</span> <span class=no>c644245001</span>      <span class=no>mov</span>     <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>50</span><span class=no>h</span><span class=p>],</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5b0</span> <span class=mi>89442448</span>        <span class=no>mov</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>48</span><span class=no>h</span><span class=p>],</span><span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5b4</span> <span class=mi>488</span><span class=no>b8424b0000000</span> <span class=no>mov</span>     <span class=no>rax</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>B0h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5bc</span> <span class=mi>4889442440</span>      <span class=no>mov</span>     <span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>40</span><span class=no>h</span><span class=p>],</span><span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5c1</span> <span class=mi>8</span><span class=no>b8424a8000000</span>  <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>A8h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016d68e5c8</span> <span class=mi>89442438</span>        <span class=no>mov</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>38</span><span class=no>h</span><span class=p>],</span><span class=no>eax</span>
</span></span></code></pre></div><p>If you want to learn more about <strong>SSDT</strong> you can read <a href=https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel>this</a>.</p><p>Now put a break point in there using <strong>bp nt!NtDeviceIoControlFile</strong>, and use <strong>g</strong> to hit that break point.
After breakpoint hit you must confirm that you are still in our process context using <strong>!process -1 0</strong> command and it have to be your exe file.Now after this part is a little bit tricky you might get BSOD multiple times, but you have to open the call stack tab and use <strong>t</strong> and <strong>pc</strong> command till you find out all the kernel APIs called to get disk serial.
After a long trace you have to see something like below which contains all the kernel APIs used to get serialnumber.</p><pre tabindex=0><code>storport!RaGetUnitStorageDeviceProperty
storport!RaUnitStorageQueryDevicePropertyIoct1+0x36
storport!RaUnitStorageQueryPropertyIoct1+0x42
storport!RaUnitDeviceControlIrp+Ox106
storport!RaDriverDeviceControlIrp+Ox5a
storport!SrbShimHookDeviceControl+0x52
nt!IofCallDriver+0x59
CLASSPNP!ClassDeviceControl+0xa47
disk!DiskDeviceControl+Oxa6
CLASSPNP!ClassDeviceControlDispatch+0x82
CLASSPNP!ClassGlobalDispatch+0x24
nt!IofCallDriver+0x59
partmgr!PmIoctlQueryProperty+Ox57
partmgr!PmFilterDeviceControl+Oxeb
partmgr!PmGlobalDispatch+0x20
nt!IofCallDriver+0x59
nt!IopSynchronousServiceTail+Ox1a5
nt!IopXxxControlFile+Oxcl0
nt!NtDeviceIoControlFile+Ox56
nt!RiSystemServiceCopyEnd+0x25
ntdll!NtDeviceIoControlFile+0x14
KERNELBASE!DeviceIoControl+0x67
KERNEL32!DeviceIoControlImplementation+0x80
</code></pre><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_1/CallStackKernelAPIs.jpg alt=Image_2></p><p>Now you know that <strong>storport.sys</strong> is the driver that gets that data, so first we get its pdb file to be able to analyze it with IDA.Simply use <strong>lm</strong> to list all modules and then find <strong>storport</strong> click on it and then click on browse all global symbols, that will cause windbg download the pdb file.
Now copy that pdb file and paste it into your VM. and on your VM go to Local Disk <strong>(C:)\Windows\System32\drivers</strong> and copy <strong>storport.sys</strong> beside its pdb and load it into IDA.</p><p>Search for <strong>RaGetUnitStorageDeviceProperty</strong> and decompile it using <strong>F5</strong> key.You can see that it uses some kind of struct and puts data into an array finally and returns it if you analyze the decompiled source. To confirm this we just need a simple debug to confirm this function gets serial disks. So once more run the compiled exe file and put a breakpoint on <strong>RaGetUnitStorageDeviceProperty</strong> using <strong>bp storport!RaGetUnitStorageDeviceProperty</strong> command.
Simply keep continuing till you hit the desired break point, now if you analyze the codes of this driver in IDA, you can see the final <strong>call</strong> instruction at the bottom. Using the <strong>pc</strong> command we debug the instruction to get to that call which you can see it below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>fffff8016edd573c</span> <span class=no>e8bfa9f9ff</span>      <span class=no>call</span>    <span class=no>storport</span><span class=p>!</span><span class=no>memcpy</span> <span class=p>(</span><span class=no>fffff8016ed70100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5741</span> <span class=mi>458</span><span class=no>bc6</span>          <span class=no>mov</span>     <span class=no>r8d</span><span class=p>,</span><span class=no>r14d</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5744</span> <span class=mi>488</span><span class=no>d542420</span>      <span class=no>lea</span>     <span class=no>rdx</span><span class=p>,[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>20</span><span class=no>h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5749</span> <span class=mi>498</span><span class=no>bcc</span>          <span class=no>mov</span>     <span class=no>rcx</span><span class=p>,</span><span class=no>r12</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd574c</span> <span class=no>e8afa9f9ff</span>      <span class=no>call</span>    <span class=no>storport</span><span class=p>!</span><span class=no>memcpy</span> <span class=p>(</span><span class=no>fffff8016ed70100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5751</span> <span class=mi>33</span><span class=no>c0</span>            <span class=no>xor</span>     <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5753</span> <span class=mi>458937</span>          <span class=no>mov</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r15</span><span class=p>],</span><span class=no>r14d</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5756</span> <span class=mi>488</span><span class=no>b8db0000000</span>  <span class=no>mov</span>     <span class=no>rcx</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rbp</span><span class=err>+</span><span class=mi>0</span><span class=no>B0h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd575d</span> <span class=mi>4833</span><span class=no>cc</span>          <span class=no>xor</span>     <span class=no>rcx</span><span class=p>,</span><span class=no>rsp</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5760</span> <span class=no>e83b9bf9ff</span>      <span class=no>call</span>    <span class=no>storport</span><span class=p>!</span><span class=no>_security_check_cookie</span> <span class=p>(</span><span class=no>fffff8016ed6f2a0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>fffff8016edd5765</span> <span class=mi>4881</span><span class=no>c4c0010000</span>  <span class=no>add</span>     <span class=no>rsp</span><span class=p>,</span><span class=mi>1</span><span class=no>C0h</span>
</span></span></code></pre></div><p>By some analyzing you can find out code will keep data in <strong>[rsp+20h]</strong>, simply if we chek this place on memory you see the below information there:</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_1/SerialsInMeomory.jpg alt=Image_3></p><h2 id=last-word>Last word<a hidden class=anchor aria-hidden=true href=#last-word>#</a></h2><p>So we confirmed this is the function, however the used struct is still unknown. We will discuss how to find it in the next part, but we mention one of the time consuming methods here and keep the neat method for the next part.You can use <strong>dt module!</strong>* which will be <strong>dt storport!</strong>* to get all the structs that <strong>strport.sys</strong> uses and then analyze them manually.
If you spend a lot of time doing reverse engineering you can confirm the struct is <strong>_RAID_UNIT_EXTENSION</strong> which will be discussed in next part.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://exists4all.github.io/tags/vmware/>VMware</a></li><li><a href=https://exists4all.github.io/tags/windows-kernel-development/>Windows Kernel Development</a></li><li><a href=https://exists4all.github.io/tags/ntoskrnl/>Ntoskrnl</a></li><li><a href=https://exists4all.github.io/tags/harddisk-serial-spoofing/>Harddisk Serial Spoofing</a></li><li><a href=https://exists4all.github.io/tags/kernel-spoofer/>Kernel Spoofer</a></li><li><a href=https://exists4all.github.io/tags/windows-internals/>Windows Internals</a></li></ul><nav class=paginav><a class=prev href=https://exists4all.github.io/posts/on_the_cryptoapi/><span class=title>« Prev</span><br><span>Analyzing CryptoAPI key extraction on Windows using CryptExportKey</span>
</a><a class=next href=https://exists4all.github.io/posts/before_start/><span class=title>Next »</span><br><span>Important notes about Kernel development on Windows</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on x" href="https://x.com/intent/tweet/?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f&amp;hashtags=VMware%2cWindowskerneldevelopment%2cntoskrnl%2cHarddiskserialspoofing%2cKernelspoofer%2cWindowsInternals"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f&amp;title=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201&amp;summary=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201&amp;source=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f&title=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201%20-%20https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on telegram" href="https://telegram.me/share/url?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%201&u=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://exists4all.github.io/>Exists4All</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
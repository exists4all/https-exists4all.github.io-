<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Analyzing CryptoAPI key extraction on Windows using CryptExportKey | Exists4All</title>
<meta name=keywords content="Windows,,CryptExportKey,CryptoAPI,,C plus plus,,Cryptography,,x64dbg,,Reverse Engineering"><meta name=description content="Doing some experiments on Windows Crypto API to gain some knowledge. We use some minimal code in C++ and x64dbg to analyze our program to see how Crypto API works."><meta name=author content="Exists4All"><link rel=canonical href=https://exists4all.github.io/posts/on_the_cryptoapi/><meta name=google-site-verification content="FJeEV8Eq61e0o2MnOwH64y1WgBV42wPtjOS_Z8FZl4c"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://exists4all.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://exists4all.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://exists4all.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://exists4all.github.io/apple-touch-icon.png><link rel=mask-icon href=https://exists4all.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://exists4all.github.io/posts/on_the_cryptoapi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Analyzing CryptoAPI key extraction on Windows using CryptExportKey"><meta property="og:description" content="Doing some experiments on Windows Crypto API to gain some knowledge. We use some minimal code in C++ and x64dbg to analyze our program to see how Crypto API works."><meta property="og:type" content="article"><meta property="og:url" content="https://exists4all.github.io/posts/on_the_cryptoapi/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-17T23:00:30+03:30"><meta property="article:modified_time" content="2024-03-17T23:00:30+03:30"><meta property="og:site_name" content="Exists4All"><meta name=twitter:card content="summary"><meta name=twitter:title content="Analyzing CryptoAPI key extraction on Windows using CryptExportKey"><meta name=twitter:description content="Doing some experiments on Windows Crypto API to gain some knowledge. We use some minimal code in C++ and x64dbg to analyze our program to see how Crypto API works."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://exists4all.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Analyzing CryptoAPI key extraction on Windows using CryptExportKey","item":"https://exists4all.github.io/posts/on_the_cryptoapi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Analyzing CryptoAPI key extraction on Windows using CryptExportKey","name":"Analyzing CryptoAPI key extraction on Windows using CryptExportKey","description":"Doing some experiments on Windows Crypto API to gain some knowledge. We use some minimal code in C++ and x64dbg to analyze our program to see how Crypto API works.","keywords":["Windows,","CryptExportKey","CryptoAPI,","C plus plus,","Cryptography,","x64dbg,","Reverse Engineering"],"articleBody":"Introduction I had to work on a PE for reverse engineering for a few weeks, the PE using an extensive amount of encryption/decryption of memory fragments to make it harder to reverse engineer it. However, that PE is for another time. But I had to write a manual encrypter/decrypter for those memory fragments to be able to patch some specific parts without changing instructions size and then crypting those bytes and replacing those specific memory fragments. However it seems the key that CryptoAPI uses to do the job is not the same as the key that you could get with CryptExportKey so I decided to look inside these functions to see what the actual key is.\nCryptoAPI basic structure CryptoAPI passes the input data as objects between its functions. The obvious reason for that is to make the attacker lifes harder. It takes your data, then hashes it with the intended algorithm, deriving its own specific key, and using them to do the job. So you can’t use your own key to encrypt/decrypt, instead you have to use its API to export the derived key based on your input. There are cases where you want to make your key exportable, but even then there are known vulnerabilities to make the key exportable. So to do a little experiment, I used this code and modified it a little bit, added my own little function and then used output to reverse engineer a specific CryptoAPI.\nExample source code The provided source code is nothing special, I compiled the file as x64 Debug mode with C++20 on Visual Studio 2022.\n#include #include #include #include #include #include #include #pragma comment(lib, \"crypt32.lib\") BOOL GetExportedKey(HCRYPTKEY hKey, DWORD dwBlobType, LPBYTE* ppbKeyBlob, LPDWORD pdwBlobLen) { DWORD dwBlobLength; *ppbKeyBlob = NULL; *pdwBlobLen = 0; // Export the public key. Here the public key is exported to a // PUBLICKEYBLOB. This BLOB can be written to a file and // sent to another user. if (CryptExportKey(hKey, NULL, dwBlobType, 0, NULL, \u0026dwBlobLength)) { printf(\"Size of the BLOB for the public key determined. \\n\"); } else { printf(\"Error computing BLOB length.\\n\"); return false; } // Allocate memory for the pbKeyBlob. if (*ppbKeyBlob = (LPBYTE)malloc(dwBlobLength)) { printf(\"Memory has been allocated for the BLOB. \\n\"); } else { printf(\"Out of memory. \\n\"); return false; } // Do the actual exporting into the key BLOB. if (CryptExportKey( hKey, NULL, dwBlobType, 0, *ppbKeyBlob, \u0026dwBlobLength)) { printf(\"Contents have been written to the BLOB. \\n\"); *pdwBlobLen = dwBlobLength; } else { printf(\"Error exporting key.\\n\"); free(*ppbKeyBlob); *ppbKeyBlob = NULL; return false; } return true; } bool ExportKeyBytes(LPBYTE keyBlob, DWORD keyBlobLength, std::vector \u003cstd::bitset\u003c8\u003e\u003e\u0026 KeyBytes) { uint32_t NumberOfBytes = *(uint32_t*)(keyBlob + sizeof(BLOBHEADER)); intptr_t StartAdrsOfKeyBytes = reinterpret_cast\u003cintptr_t\u003e((keyBlob + sizeof(BLOBHEADER) + sizeof(DWORD))); std::cout \u003c\u003c std::endl \u003c\u003c \"------Exctracted key bytes are as below--------\" \u003c\u003c std::endl; for (uint16_t j = 0; j \u003c NumberOfBytes; j++) { KeyBytes.push_back(*((std::bitset\u003c8\u003e*)StartAdrsOfKeyBytes)); StartAdrsOfKeyBytes++; unsigned long int Mask = 0b0000000011111111; Mask \u0026= (KeyBytes[j].to_ulong()); std::cout \u003c\u003c \" \" \u003c\u003c std::hex \u003c\u003c Mask; } std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"The bit representation of key blob:\" \u003c\u003c std::endl; for (uint16_t j = 0; j \u003c KeyBytes.size(); j++) std::cout \u003c\u003c std::bitset\u003c8\u003e((KeyBytes[j])); std::cout \u003c\u003c std::endl; return true; } int main() { HCRYPTPROV hProv = 0; HCRYPTKEY hKey = 0; HCRYPTHASH hHash = 0; DWORD dwCount = 5; LPBYTE keyBlob = NULL; DWORD keyBlobLength; LPSTR keyBlobBase64 = NULL; DWORD base64Length = 0; BYTE rgData[512] = { 0x01, 0x02, 0x03, 0x04, 0x05 }; LPWSTR wszPassword = (LPWSTR)L\"password12\"; DWORD cbPassword = (wcslen(wszPassword) + 1) * sizeof(WCHAR); if (!CryptAcquireContext( \u0026hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { printf(\"Error %x during CryptAcquireContext!\\n\", GetLastError()); goto Cleanup; } if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, \u0026hHash)) { printf(\"Error %x during CryptCreateHash!\\n\", GetLastError()); goto Cleanup; } if (!CryptHashData(hHash, (PBYTE)wszPassword, cbPassword, 0)) { printf(\"Error %x during CryptHashData!\\n\", GetLastError()); goto Cleanup; } if (!CryptDeriveKey(hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, \u0026hKey)) { printf(\"Error %x during CryptDeriveKey!\\n\", GetLastError()); goto Cleanup; } if (!GetExportedKey(hKey, PLAINTEXTKEYBLOB, \u0026keyBlob, \u0026keyBlobLength)) { printf(\"Error %x during GetExportedKey!\\n\", GetLastError()); goto Cleanup; } while (1) { // PLAINTEXTKEYBLOB: BLOBHEADER|DWORD key length|Key material| DWORD keyMaterialLength; LPBYTE keyMaterial; keyMaterialLength = *(DWORD*)(keyBlob + sizeof(BLOBHEADER)); keyMaterial = (keyBlob + sizeof(BLOBHEADER) + sizeof(DWORD)); if (!CryptBinaryToStringA(keyMaterial, keyMaterialLength, CRYPT_STRING_BASE64, keyBlobBase64, \u0026base64Length)) { printf(\"Error %x during GetExportedKey!\\n\", GetLastError()); goto Cleanup; } if (keyBlobBase64) { std::cout \u003c\u003c std::endl \u003c\u003c \"Base64 string representation of key blob:--------\" \u003c\u003c std::endl; printf(\"%d-bit key blob: %s\\n\", keyMaterialLength * 8, keyBlobBase64); break; } else { keyBlobBase64 = (LPSTR)malloc(base64Length); std::vector \u003cstd::bitset\u003c8\u003e\u003e KeyBytes; ExportKeyBytes(keyBlob, keyBlobLength, KeyBytes); std::cout \u003c\u003c \"------ _PLAINTEXTKEYBLOB struct bytes are as below:--------\" \u003c\u003c std::endl; for (unsigned int j = 0; j \u003c keyBlobLength; j++) printf(\"%02x \", ((char*)keyBlob)[j] \u0026 0b0000000011111111); std::cout \u003c\u003c std::endl; } } std::cout \u003c\u003c \"------ Data bytes before encyption:--------\" \u003c\u003c std::endl; for (DWORD i = 0; i \u003c dwCount; i++) { printf(\"%d \", rgData[i]); } printf(\"\\n\"); if (!CryptEncrypt(hKey, 0, TRUE, 0, rgData, \u0026dwCount, sizeof(rgData))) { printf(\"Error %x during CryptEncrypt!\\n\", GetLastError()); goto Cleanup; } std::cout \u003c\u003c \"------ Data bytes after encyption:--------\" \u003c\u003c std::endl; for (DWORD i = 0; i \u003c dwCount; i++) { printf(\"%02x \", ((char*)rgData)[i] \u0026 0b0000000011111111); } printf(\"\\n\"); Cleanup: free(keyBlob); free(keyBlobBase64); if (hKey) { CryptDestroyKey(hKey); } if (hHash) { CryptDestroyHash(hHash); } if (hProv) { CryptReleaseContext(hProv, 0); } return 0; } And after running the program you will see the following output:\nSize of the BLOB for the public key determined. Memory has been allocated for the BLOB. Contents have been written to the BLOB. ------Exctracted key bytes are as below-------- 83 30 c7 bb 70 The bit representation of key blob: 1000001100110000110001111011101101110000 ------ _PLAINTEXTKEYBLOB struct bytes are as below:-------- 08 02 00 00 01 68 00 00 05 00 00 00 83 30 c7 bb 70 Base64 string representation of key blob:-------- 40-bit key blob: gzDHu3A= ------ Data bytes before encyption:-------- 1 2 3 4 5 ------ Data bytes after encyption:-------- 0e 39 88 22 87 As you can see the key size should be 5 bytes, and you can see them as 83 30 c7 bb 70, however if you try to decrypt bytes 0e 39 88 22 87, it does not work. I had to look inside the CryptEncrypt to see what the key was.\nAnalysis For the debugging I used x64dbg and Ghidra. The two dlls that we need are cryptsp.dll and rsaenh.dll. So just find them in your windows directory, or use the provided ones in the archive. After you found them you can use symchk.exe to download the PDB files to use them with Ghidra with the following command:\nsymchk.exe \"C:\\dllname.dll\" /s SRV*C:\\*http://msdl.microsoft.com/download/symbols The command will download the PDB in C directory for the provided dll in C directory. So finally drag dll files in Ghidra and let them analyzed with PDB files. If the above command did not worked (you have to install WDK before), you can search for symchk.exe on the installed location of WDK, then open CMD as admin and them going to the location of sychk.exe them execute command in that address. So we open the file in x64dbg and put a breakpoint on CryptEncrypt.\nThen head to the call stack so we can put a BP inside our program to be able see passing arguments. Simple click on the highlighted green address.\nSo we put a BP on the CryptEncrypt inside main.\nNow we restart debugger and hit run till hitting the BP inside main. We know CryptEncrypt takes 7 arguments and the first argument is a pointer to the hashed blob. So we just look at stack:\nSo we just follow that address in memory by clicking on it and following it in the dump. So we just follow that address in memory by clicking on it and following it in the dump. After a little bit analysis you will notice we are seeing numbers 11 and 5 in memory regardless of number of execution, so it is a good idea to put hardware dword access breakpoint on bytes 05 00 00 00.\nAfter putting that BP, we execute the program till it gets hit.\nIn the image you can see all the information. So CryptEncrypt uses 16 bytes keys, and you can clearly see our program output bytes 83 30 c7 bb 70 with following zeros. Now if you simply use key 83 30 c7 bb 70 00 00 00 00 00 00 00 00 00 00 00, for RC4 algorithm you can crypt our input bytes 01 02 03 04 05. I was not able to find much information about it so I thought it’s a good idea to share it here.\nLast word Even though I was able to find the actual key for the RC4 algorithm, looking at decompiled code in Ghidra, it is not very clear for obvious reasons.\nIf you are looking for more, you can also read this and this. But for now I think this will be enough for me to finish my other projects.\n","wordCount":"1468","inLanguage":"en","datePublished":"2024-03-17T23:00:30+03:30","dateModified":"2024-03-17T23:00:30+03:30","author":{"@type":"Person","name":"Exists4All"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://exists4all.github.io/posts/on_the_cryptoapi/"},"publisher":{"@type":"Organization","name":"Exists4All","logo":{"@type":"ImageObject","url":"https://exists4all.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://exists4all.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://exists4all.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://exists4all.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://exists4all.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://exists4all.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://exists4all.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Analyzing CryptoAPI key extraction on Windows using CryptExportKey</h1><div class=post-description>Doing some experiments on Windows Crypto API to gain some knowledge. We use some minimal code in C++ and x64dbg to analyze our program to see how Crypto API works.</div><div class=post-meta><span title='2024-03-17 23:00:30 +0330 +0330'>March 17, 2024</span>&nbsp;·&nbsp;1468 words&nbsp;·&nbsp;Exists4All&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/On_The_Cryptoapi.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>I had to work on a PE for reverse engineering for a few weeks, the PE using an extensive amount of encryption/decryption of memory fragments to make it harder to reverse engineer it. However, that PE is for another time. But I had to write a manual encrypter/decrypter for those memory fragments to be able to patch some specific parts without changing instructions size and then crypting those bytes and replacing those specific memory fragments. However it seems the key that CryptoAPI uses to do the job is not the same as the key that you could get with CryptExportKey so I decided to look inside these functions to see what the actual key is.</p><hr><h2 id=cryptoapi-basic-structure>CryptoAPI basic structure<a hidden class=anchor aria-hidden=true href=#cryptoapi-basic-structure>#</a></h2><p>CryptoAPI passes the input data as objects between its functions. The obvious reason for that is to make the attacker lifes harder. It takes your data, then hashes it with the intended algorithm, deriving its own specific key, and using them to do the job.
So you can’t use your own key to encrypt/decrypt, instead you have to use its API to export the derived key based on your input. There are cases where you want to make your key exportable, but even then there are known vulnerabilities to make the key exportable.
So to do a little experiment, I used <a href="https://stackoverflow.com/questions/29586097/how-to-export-aes-key-derived-using-cryptoapi?noredirect=1&amp;lq=1">this</a> code and modified it a little bit, added my own little function and then used output to reverse engineer a specific CryptoAPI.</p><hr><h2 id=example-source-code>Example source code<a hidden class=anchor aria-hidden=true href=#example-source-code>#</a></h2><p>The provided source code is nothing special, I compiled the file as x64 Debug mode with C++20 on Visual Studio 2022.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;Windows.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bitset&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#pragma comment(lib, &#34;crypt32.lib&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>GetExportedKey</span><span class=p>(</span><span class=n>HCRYPTKEY</span> <span class=n>hKey</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>dwBlobType</span><span class=p>,</span> <span class=n>LPBYTE</span><span class=o>*</span> <span class=n>ppbKeyBlob</span><span class=p>,</span> <span class=n>LPDWORD</span> <span class=n>pdwBlobLen</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwBlobLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ppbKeyBlob</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pdwBlobLen</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Export the public key. Here the public key is exported to a 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// PUBLICKEYBLOB. This BLOB can be written to a file and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// sent to another user.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>CryptExportKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwBlobType</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dwBlobLength</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Size of the BLOB for the public key determined. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error computing BLOB length.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocate memory for the pbKeyBlob.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>ppbKeyBlob</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPBYTE</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>dwBlobLength</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Memory has been allocated for the BLOB. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Out of memory. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do the actual exporting into the key BLOB.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>CryptExportKey</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>hKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>dwBlobType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>ppbKeyBlob</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>dwBlobLength</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Contents have been written to the BLOB. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pdwBlobLen</span> <span class=o>=</span> <span class=n>dwBlobLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error exporting key.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=o>*</span><span class=n>ppbKeyBlob</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>ppbKeyBlob</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>ExportKeyBytes</span><span class=p>(</span><span class=n>LPBYTE</span> <span class=n>keyBlob</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>keyBlobLength</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span> <span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=mi>8</span><span class=o>&gt;&gt;&amp;</span> <span class=n>KeyBytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>NumberOfBytes</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span><span class=o>*</span><span class=p>)(</span><span class=n>keyBlob</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BLOBHEADER</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=n>StartAdrsOfKeyBytes</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>intptr_t</span><span class=o>&gt;</span><span class=p>((</span><span class=n>keyBlob</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BLOBHEADER</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------Exctracted key bytes are as below--------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint16_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>NumberOfBytes</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>KeyBytes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>*</span><span class=p>((</span><span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=mi>8</span><span class=o>&gt;*</span><span class=p>)</span><span class=n>StartAdrsOfKeyBytes</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>StartAdrsOfKeyBytes</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>Mask</span> <span class=o>=</span> <span class=mb>0b0000000011111111</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Mask</span> <span class=o>&amp;=</span> <span class=p>(</span><span class=n>KeyBytes</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>to_ulong</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=n>Mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The bit representation of key blob:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>uint16_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>KeyBytes</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=mi>8</span><span class=o>&gt;</span><span class=p>((</span><span class=n>KeyBytes</span><span class=p>[</span><span class=n>j</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HCRYPTPROV</span> <span class=n>hProv</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HCRYPTKEY</span> <span class=n>hKey</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HCRYPTHASH</span> <span class=n>hHash</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwCount</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPBYTE</span> <span class=n>keyBlob</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>keyBlobLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPSTR</span> <span class=n>keyBlobBase64</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>base64Length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span>  <span class=n>rgData</span><span class=p>[</span><span class=mi>512</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x02</span><span class=p>,</span> <span class=mh>0x03</span><span class=p>,</span> <span class=mh>0x04</span><span class=p>,</span> <span class=mh>0x05</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>LPWSTR</span> <span class=n>wszPassword</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPWSTR</span><span class=p>)</span><span class=sa>L</span><span class=s>&#34;password12&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>cbPassword</span> <span class=o>=</span> <span class=p>(</span><span class=n>wcslen</span><span class=p>(</span><span class=n>wszPassword</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WCHAR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptAcquireContext</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;</span><span class=n>hProv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>MS_DEF_PROV</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>PROV_RSA_FULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>CRYPT_VERIFYCONTEXT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during CryptAcquireContext!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptCreateHash</span><span class=p>(</span><span class=n>hProv</span><span class=p>,</span> <span class=n>CALG_MD5</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hHash</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during CryptCreateHash!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptHashData</span><span class=p>(</span><span class=n>hHash</span><span class=p>,</span> <span class=p>(</span><span class=n>PBYTE</span><span class=p>)</span><span class=n>wszPassword</span><span class=p>,</span> <span class=n>cbPassword</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during CryptHashData!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptDeriveKey</span><span class=p>(</span><span class=n>hProv</span><span class=p>,</span> <span class=n>CALG_RC4</span><span class=p>,</span> <span class=n>hHash</span><span class=p>,</span> <span class=n>CRYPT_EXPORTABLE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during CryptDeriveKey!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>GetExportedKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=n>PLAINTEXTKEYBLOB</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>keyBlob</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>keyBlobLength</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during GetExportedKey!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// PLAINTEXTKEYBLOB: BLOBHEADER|DWORD key length|Key material|
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DWORD</span> <span class=n>keyMaterialLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>LPBYTE</span> <span class=n>keyMaterial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>keyMaterialLength</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)(</span><span class=n>keyBlob</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BLOBHEADER</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>keyMaterial</span> <span class=o>=</span> <span class=p>(</span><span class=n>keyBlob</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BLOBHEADER</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptBinaryToStringA</span><span class=p>(</span><span class=n>keyMaterial</span><span class=p>,</span> <span class=n>keyMaterialLength</span><span class=p>,</span> <span class=n>CRYPT_STRING_BASE64</span><span class=p>,</span> <span class=n>keyBlobBase64</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>base64Length</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during GetExportedKey!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>keyBlobBase64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base64 string representation of key blob:--------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d-bit key blob: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>keyMaterialLength</span> <span class=o>*</span> <span class=mi>8</span><span class=p>,</span> <span class=n>keyBlobBase64</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>keyBlobBase64</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPSTR</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>base64Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>vector</span> <span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>bitset</span><span class=o>&lt;</span><span class=mi>8</span><span class=o>&gt;&gt;</span> <span class=n>KeyBytes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ExportKeyBytes</span><span class=p>(</span><span class=n>keyBlob</span><span class=p>,</span> <span class=n>keyBlobLength</span><span class=p>,</span> <span class=n>KeyBytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------ _PLAINTEXTKEYBLOB struct bytes are as below:--------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>keyBlobLength</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%02x &#34;</span><span class=p>,</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>keyBlob</span><span class=p>)[</span><span class=n>j</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mb>0b0000000011111111</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------ Data bytes before encyption:--------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>DWORD</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>dwCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=n>rgData</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CryptEncrypt</span><span class=p>(</span><span class=n>hKey</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>TRUE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>rgData</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dwCount</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rgData</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error %x during CryptEncrypt!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>Cleanup</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------ Data bytes after encyption:--------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>DWORD</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>dwCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%02x &#34;</span><span class=p>,</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>rgData</span><span class=p>)[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mb>0b0000000011111111</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>Cleanup</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>keyBlob</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>keyBlobBase64</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hKey</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptDestroyKey</span><span class=p>(</span><span class=n>hKey</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hHash</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptDestroyHash</span><span class=p>(</span><span class=n>hHash</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hProv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CryptReleaseContext</span><span class=p>(</span><span class=n>hProv</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And after running the program you will see the following output:</p><pre tabindex=0><code>Size of the BLOB for the public key determined.
Memory has been allocated for the BLOB.
Contents have been written to the BLOB.

------Exctracted key bytes are as below--------
83 30 c7 bb 70
The bit representation of key blob:
1000001100110000110001111011101101110000
------ _PLAINTEXTKEYBLOB struct bytes are as below:--------
08 02 00 00 01 68 00 00 05 00 00 00 83 30 c7 bb 70

Base64 string representation of key blob:--------
40-bit key blob: gzDHu3A=

------ Data bytes before encyption:--------
1 2 3 4 5
------ Data bytes after encyption:--------
0e 39 88 22 87
</code></pre><p>As you can see the key size should be <strong>5 bytes</strong>, and you can see them as <strong>83 30 c7 bb 70</strong>, however if you try to decrypt bytes <strong>0e 39 88 22 87</strong>, it does not work. I had to look inside the <strong>CryptEncrypt</strong> to see what the key was.</p><hr><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><p>For the debugging I used x64dbg and Ghidra. The two dlls that we need are cryptsp.dll and rsaenh.dll. So just find them in your windows directory, or use the provided ones in the archive. After you found them you can use symchk.exe to download the PDB files to use them with Ghidra with the following command:</p><pre tabindex=0><code>symchk.exe &#34;C:\dllname.dll&#34; /s SRV*C:\*http://msdl.microsoft.com/download/symbols
</code></pre><p>The command will download the PDB in C directory for the provided dll in C directory. So finally drag dll files in Ghidra and let them analyzed with PDB files. If the above command did not worked (you have to install WDK before), you can search for symchk.exe on the installed location of WDK, then open CMD as admin and them going to the location of sychk.exe them execute command in that address. So we open the file in x64dbg and put a breakpoint on CryptEncrypt.</p><p><img loading=lazy src=/On_The_Cryptoapi/1.png alt=Image_1></p><p>Then head to the call stack so we can put a BP inside our program to be able see passing arguments. Simple click on the highlighted green address.</p><p><img loading=lazy src=/On_The_Cryptoapi/2.png alt=Image_2></p><p>So we put a BP on the CryptEncrypt inside main.</p><p><img loading=lazy src=/On_The_Cryptoapi/3.png alt=Image_3></p><p>Now we restart debugger and hit run till hitting the BP inside main. We know CryptEncrypt takes 7 arguments and the first argument is a pointer to the hashed blob. So we just look at stack:</p><p><img loading=lazy src=/On_The_Cryptoapi/4.png alt=Image_4></p><p>So we just follow that address in memory by clicking on it and following it in the dump. So we just follow that address in memory by clicking on it and following it in the dump. After a little bit analysis you will notice we are seeing numbers 11 and 5 in memory regardless of number of execution, <strong>so it is a good idea to put hardware dword access breakpoint on bytes 05 00 00 00</strong>.</p><p><img loading=lazy src=/On_The_Cryptoapi/5.png alt=Image_5></p><p>After putting that BP, we execute the program till it gets hit.</p><p><img loading=lazy src=/On_The_Cryptoapi/6.png alt=Image_6></p><p>In the image you can see all the information. So CryptEncrypt uses 16 bytes keys, and you can clearly see our program output bytes <strong>83 30 c7 bb 70</strong> with following zeros. Now if you simply use key <strong>83 30 c7 bb 70 00 00 00 00 00 00 00 00 00 00 00</strong>, for <strong>RC4</strong> algorithm you can crypt our input bytes <strong>01 02 03 04 05</strong>.
I was not able to find much information about it so I thought it’s a good idea to share it here.</p><hr><h2 id=last-word>Last word<a hidden class=anchor aria-hidden=true href=#last-word>#</a></h2><p>Even though I was able to find the actual key for the RC4 algorithm, looking at decompiled code in Ghidra, it is not very clear for obvious reasons.</p><p><img loading=lazy src=/On_The_Cryptoapi/7.png alt=Image_7></p><p>If you are looking for more, you can also read <a href=https://arm-software.github.io/psa-api/crypto/1.1/IHI0086-PSA_Certified_Crypto_API-1.1.2.pdf>this</a> and <a href=https://research.nccgroup.com/wp-content/uploads/2020/07/exporting_non-exportable_rsa_keys.pdf>this</a>. But for now I think this will be enough for me to finish my other projects.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://exists4all.github.io/tags/cryptoapi/>CryptoAPI</a></li><li><a href=https://exists4all.github.io/tags/windows-api/>Windows API</a></li><li><a href=https://exists4all.github.io/tags/hash/>Hash</a></li><li><a href=https://exists4all.github.io/tags/reverse-engineering-windows/>Reverse Engineering Windows</a></li></ul><nav class=paginav><a class=prev href=https://exists4all.github.io/posts/simpepecrypter/><span class=title>« Prev</span><br><span>How to create your own PE Crypter with C++ from scratch</span>
</a><a class=next href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/><span class=title>Next »</span><br><span>How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on x" href="https://x.com/intent/tweet/?text=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f&amp;hashtags=CryptoAPI%2cWindowsAPI%2cHash%2cReverseEngineeringWindows"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f&amp;title=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey&amp;summary=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey&amp;source=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f&title=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on whatsapp" href="https://api.whatsapp.com/send?text=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey%20-%20https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on telegram" href="https://telegram.me/share/url?text=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Analyzing CryptoAPI key extraction on Windows using CryptExportKey on ycombinator" href="https://news.ycombinator.com/submitlink?t=Analyzing%20CryptoAPI%20key%20extraction%20on%20Windows%20using%20CryptExportKey&u=https%3a%2f%2fexists4all.github.io%2fposts%2fon_the_cryptoapi%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://exists4all.github.io/>Exists4All</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
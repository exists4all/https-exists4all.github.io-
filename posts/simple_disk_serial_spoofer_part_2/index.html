<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 | Exists4All</title>
<meta name=keywords content="Windows,,Kernel,,Driver Development,,Reverse Engineering,,Kernel,,Windows,,Spoofer,,Disk,,Serial,,Disk Serial,,Tutorial,,Static SPoofer"><meta name=description content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><meta name=author content="Exists4All"><link rel=canonical href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_2/><meta name=google-site-verification content="FJeEV8Eq61e0o2MnOwH64y1WgBV42wPtjOS_Z8FZl4c"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://exists4all.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://exists4all.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://exists4all.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://exists4all.github.io/apple-touch-icon.png><link rel=mask-icon href=https://exists4all.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2"><meta property="og:description" content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><meta property="og:type" content="article"><meta property="og:url" content="https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T19:01:18+03:30"><meta property="article:modified_time" content="2024-10-22T19:01:18+03:30"><meta property="og:site_name" content="Exists4All"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2"><meta name=twitter:description content="In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://exists4all.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2","item":"https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2","name":"How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2","description":"In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0.","keywords":["Windows,","Kernel,","Driver Development,","Reverse Engineering,","Kernel,","Windows,","Spoofer,","Disk,","Serial,","Disk Serial,","Tutorial,","Static SPoofer"],"articleBody":" An author never does more damage to his readers than when he hides a difficulty. (Evariste Galois)\nYou can download this tutorial and all necessary files in an archive file from here. The PDF version is also available here.\nFile password:\nexists4all.github.io Table of Contents Introduction Abstract Required tools Required knowledge Purpose Windows Internal and Hard disks Device Unique Identifiers (DUIDs) for Storage Devices Looking inside kernel architecture Find hard disks objects and The responsible driver that gets disk serials Reimplementing spoofer n0Lin (@Alex3434) and btbd spoofer Logic of implementation Updating SamuelTulach project Conclusion Introduction Abstract After a long time being inactive I decided to finish my break due to some personal reasons. And one other reason was that it was getting closer to release date of Windows 24H2. After the release I noticed old spoofers cause problems and lead to BSOD so it’s the best time to write a part 2 of the static spoofer tutorial. We are going to use amazing old work of other people to make our life simpler. We are basically going to do some reverse engineering and modify old spoofers to work on a new build of Windows and explain the philosophy of it. You can download most of the used resources and important files in this tutorial on my website. I also really appreciate any suggestion, and pointing out any errors since no one is prone to making mistakes. You can do that using this form.\nRequired tools As usual, we are going to use the most used tools. I list them below.\nWindows 11 24H2 Visial Studio Compatible SDK + WDK with Windows 11 24H2 Windbg Preview Hyper-V with host OS IDA WinObj tool An Intel CPU with Intel Virtualization Technology Required knowledge Before starting, take a look at [Disk Serial Spoofer on Windows part 1].\nPurpose In this tutorial we are mainly trying to analyze WIndows internals and learn about Hard disks more. These methods by no means are enough to bypass modern kernel anti cheats. There are lots of ways to track modifications and get DiskSerials later. For example Vanguard anti-cheat will start before most drivers and will track all the HWIDs before even spoofing them with these outdated methods. However, this is a good opportunity to learn the basics and develop more advanced spoofers by merging new methods and tools with it.\nWindows Internal and Hard disks Device Unique Identifiers (DUIDs) for Storage Devices Techniques to identify storage devices become inadequate as file system architecture becomes more complex, the number of operating system components multiplies, and initiators access storage targets through increasingly diverse hardware and software paths. For example, the Plug and Play (PnP) manager generates an instance identifier (ID) for each device in the computer. Each instance ID corresponds to a single device node in the device tree and uniquely identifies a device, if the device remains in the same location. Instance IDs persist when a computer is restarted, but they do not remain the same if you move the device to a different bus or a different computer. As a result, instance IDs are inadequate for applications in storage area networks (SANs) and for some newer system components, such as the Windows Vista Diagnostic Service, that operate in environments with distributed storage. When a hard disk drive predicts a SMART failure, it generates an event for the diagnostic service. This event must contain an identifier that uniquely identifies the failing hard disk on all computers that the disk could be in and on all buses that it could be attached to. Instance IDs and any of the other device identification strings are inadequate for this purpose. Some applications and system services, such as the Microsoft Cluster Service MSCS and the Partition Manager, use the device layout signature STORAGE_DEVICE_LAYOUT_SIGNATURE to uniquely identify a storage device in a cluster. But the device layout signature is inadequate for this purpose, under certain circumstances, and includes the following limitations: 1. The signature might change or be cleared. 2. The signature might be unavailable if the device is not spinning or has problems accessing the sectors where the signature resides. 3. The signature is unavailable if the disk is reserved by another cluster node. MSCS can read the drive layout of only disks that are associated with the node that MSCS is running on. Software that must access disks in different cluster nodes must use an alternative to the disk layout signature. 4. Drive layout signatures cannot help distinguish between a logical unit number (LUN) and its snapshot. Because a LUN and its snapshot have identical content, their drive layout signatures will be the same.\nA serial number is sometimes a reliable technique of uniquely identifying a storage device that does not depend on the location of the device. The serial number is often available as a part of a device’s inquiry data. Initiators can query for the inquiry data with a IOCTL_STORAGE_QUERY_PROPERTY request, and the port driver reports the results of the query in a STORAGE_DEVICE_DESCRIPTOR structure. However, this technique does not help identify devices, such as tape drives, that do not report inquiry data.[2]\nOne can see now how serial numbers can be obtained by the last part of the referenced quote above.\nLooking inside kernel architecture As I mentioned before, Kernel-Mode Driver Architecture Design Guide is a very important resource to study. The natural question before spoofing serial numbers is how windows actually get them when the system starts, to answer this question we have to go through the mentioned guide of Microsoft. Almost all of the following paragraphs are direct quotes from Microsoft.\nWindows manages its own internal with Objects, thus we have multiple kinds of objects that windows use, among them we can name Device objects,Symbolic links,Registry keys and more. Each object has a header (containing information about the object such as its name, type, and location), and a body (containing data in a format determined by each type of object).[3][4]\nAll the Internals of Windows are treated as Objects. Drivers are Object structures themselves that contain sub structures as well.\nThe I/O manager creates a driver object for each driver that has been installed and loaded. Driver objects are defined using DRIVER_OBJECT structures. When the I/O manager calls a driver’s DriverEntry routine, it supplies the address of the driver’s driver object. The driver object contains storage for entry points to many of a driver’s standard routines. The driver is responsible for filling in these entry points[5].\nKernel-mode objects are either named or unnamed and named objects are organized into a hierarchy. For example, \\KernelObjects\\LowMemoryCondition is the name of the standard event object that signals when the amount of free memory in the system is low. Drivers that create named objects do so in specific object directories[6].\nEach driver can create multiple objects and contain predefined objects as well which usually obey hierarchy. So there can be multiple objects that are related to a single Driver. Also there could be a single Object which is related to multiple Drivers.\nAn object directory is a named object that is used solely to contain other named objects. For example, the \\Device object directory contains the named device objects created by drivers. The following is a list of the top-level object directories that contain objects drivers might create or use:\n\\Callbacks \\Device \\KernelObjects \\DosDevices Drivers can create new object directories by calling the ZwCreateDirectoryObject routine[7].\nMultiple Drivers can create different objects in the same directory. Directories help to maintain object oriented kernels.\nObject manager has to keep track of references, count them and maintain them, it also has to do the same for handles. Some anticheats for example can use the number of open handles to keep track of suspicious programs. The Object manager also destroys objects if they do not have any reference. To be able to see how the Object and Object directory work better you can use the WinObj tool, which we will do later to find hard disks[8 p13-p15].\nAs we pointed out before, Drivers treated as objects. The defined structure for a driver Object is as below:\ntypedef struct _DRIVER_OBJECT { CSHORT Type; CSHORT Size; PDEVICE_OBJECT DeviceObject; ULONG Flags; PVOID DriverStart; ULONG DriverSize; PVOID DriverSection; PDRIVER_EXTENSION DriverExtension; UNICODE_STRING DriverName; PUNICODE_STRING HardwareDatabase; PFAST_IO_DISPATCH FastIoDispatch; PDRIVER_INITIALIZE DriverInit; PDRIVER_STARTIO DriverStartIo; PDRIVER_UNLOAD DriverUnload; PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1]; } DRIVER_OBJECT, * PDRIVER_OBJECT; It’s clear now each Driver has at least one Device Object. The operating system represents devices by device objects. One or more device objects are associated with each device. Device objects serve as the target of all operations on the device. Kernel-mode drivers must create at least one device object for each device, with the few exceptions[9].\nThere are three kinds of WDM device objects:\nPhysical Device Object (PDO) – represents a device on a bus to a bus driver. Functional Device Object (FDO) – represents a device to a function driver. Filter Device Object (filter DO) – represents a device to a filter driver[10]. And finally the DEVICE_OBJECT struct is defined as below:\ntypedef struct _DEVICE_OBJECT { CSHORT Type; USHORT Size; LONG ReferenceCount; struct _DRIVER_OBJECT * DriverObject; struct _DEVICE_OBJECT * NextDevice; struct _DEVICE_OBJECT * AttachedDevice; struct _IRP * CurrentIrp; PIO_TIMER Timer; ULONG Flags; ULONG Characteristics; __volatile PVPB Vpb; PVOID DeviceExtension; DEVICE_TYPE DeviceType; CCHAR StackSize; union { LIST_ENTRY ListEntry; WAIT_CONTEXT_BLOCK Wcb; } Queue; ULONG AlignmentRequirement; KDEVICE_QUEUE DeviceQueue; KDPC Dpc; ULONG ActiveThreadCount; PSECURITY_DESCRIPTOR SecurityDescriptor; KEVENT DeviceLock; USHORT SectorSize; USHORT Spare1; struct _DEVOBJ_EXTENSION * DeviceObjectExtension; PVOID Reserved; } DEVICE_OBJECT, * PDEVICE_OBJECT; The windows start identifying hardwares at the boot time and keep tracking them in an object, called Device tree. The PnP manager maintains a device tree that keeps track of the devices in the system. The following figure shows the device tree for a sample system configuration. The device tree contains information about the devices present on the system. The PnP manager builds this tree when the machine boots, using information from drivers and other components, and updates the tree as devices are added or removed. Each node of the device tree is called a device node, or devnode. A devnode consists of the device objects for the device’s drivers, plus internal information maintained by the system. Therefore, there is a devnode for each device stack[11].\nThe PnP manager will find hard disks, and add them to the Device tree at boot time. It also keeps track of hardwares in case new hardware is added or unplugged.\nFind hard disks objects and The responsible driver that gets disk serials To be able to see where the hard disk objects are, we use the WinObJ tool from sysinternals[12]. Simply download the tool and run it as administrator.\nSimply download the tool and run it as administrator. As we mentioned before, \\Device is one of the important object directories. Simply looking inside that directory you can see different kinds of identified hardwares there. In the picture of Device Tree you can see Hard disks are related to the SCSI port. Thus by searching the \\Device directory you will be able to see symbolic links starting with the name ScsiPort name and then numbered in order. And there are actually Objects called RaidPort in the directory. So our job is to find and modify these Objects property.\nAs for the second part, which we explained in part 1 already, we just use a simple C++ code that gets a hard disk serial. Putting a breakpoint in the main function and keep debugging it using pc and t command till we reach a syscall. Then using the SSD table we find the kernel function that is going to be called and put a breakpoint on it. In part one I explain that after this you just have to keep using pc and t command till you find the function, however to make our own life easier, this time we are going to use script this time.\nSimply boot up your Hyper-V and connect Windbg preview to it. If you do not know how to set these things up, read here to setup Hyper-V and here to set up WDK before installing Windbg Preview and after that install Windbg Preview. After that download this C++ code, put __debugbreak() in the main and compile it. Then Move the compiled file into the VM and run it.\nYou can add the path of the source and PDB of the compiled file to the Windbg to be able to debug it by source. After running the file, the breakpoint will get hit, use !sym noisy and .reload command and then simply simply use pc and t command till you hit a syscall.\nAfter hitting the syscall, we have to find which kernel function is going to be called using the SSD table. For more details about the SSD table read here. I am just going to explain it in the cookie cutter format. First look at the RAX register value, in my case it is RAX=0x7. Next you have to execute the following command:\ndd nt!KiServiceTable+0xRAXValue*0x4 L1 So in my case it looks like that dd nt!KiServiceTable+0x7*0x4 L1, that will cause windbg return first value of table. In my case the result is fffff806`804d40bc 07b4bf06. Use the second value in the following command:\nu KiServiceTable + (0xReturnedValue\u003e\u003e4) So in my case it looks like that u KiServiceTable + (0x7b4bf06»4). After that you will see the instructions like below:\nnt!NtDeviceIoControlFile: fffff806`80c88c90 4883ec68 sub rsp,68h fffff806`80c88c94 8b8424b8000000 mov eax,dword ptr [rsp+0B8h] fffff806`80c88c9b c744245800000000 mov dword ptr [rsp+58h],0 fffff806`80c88ca3 c644245001 mov byte ptr [rsp+50h],1 fffff806`80c88ca8 89442448 mov dword ptr [rsp+48h],eax fffff806`80c88cac 488b8424b0000000 mov rax,qword ptr [rsp+0B0h] fffff806`80c88cb4 4889442440 mov qword ptr [rsp+40h],rax fffff806`80c88cb9 8b8424a8000000 mov eax,dword ptr [rsp+0A8h] Now we just put a breakpoint on this kernel function with this bp nt!NtDeviceIoControlFile. Then hit g command to continue execution. Keep in mind after each hit, we have to check execution context to be sure that this breakpoint that we landed on is related to our program with this command !process -1 0. After you confirm the landing breakpoint is for our program disable it. Then we need to use a script to execute t and pc commands automatically many times so we don’t have to do it manually. To do this we create a file named Script.js and paste the following code in it:\nfunction invokeScript() { var ctl = host.namespace.Debugger.Utility.Control; var output; for(var i=1; i \u003c= 20; i+=2) { output = ctl.ExecuteCommand(\"pc\"); host.diagnostics.debugLog(\" \", i, \"\\n\"); output = ctl.ExecuteCommand(\"t\"); host.diagnostics.debugLog(\" \", i+1, \"\\n\"); } } To learn more about scripting you can read here. No simply running the script with .scriptrun ScriptPath\\textbackslash Script.js, Where ScriptPath should point to the absolute location of the script. After each execution of this script, we have to check stack call to see interesting functions. Then based on our experience we use t and pc commands manually to slowly observe what will happen. This script is just used to get rid of lot’s of obvious executions in the early stages. Keep in mind there might be BSOD happening a few times. So you just have to start all over again if that happens. If the script is stuck, pausing and unpausing the Hyper-V can help sometimes. After 4 times script execution and a few manual execution commands I arrived at the following calls:\nstorport!RaGetUnitStorageDeviceProperty+0x4d storport!RaUnitStorageQueryPropertyIoctl+0x172 storport!RaUnitDeviceControlIrp+0x19d storport!RaDriverDeviceControlIrp+0x8c nt!IofCallDriver+0xbe CLASSPNP!ClassDeviceControl+0x51a disk!DiskDeviceControl+0xf4 CLASSPNP!ClassDeviceControlDispatch+0x91 CLASSPNP!ClassGlobalDispatch+0x3a nt!IofCallDriver+0xbe partmgr!PmIoctlQueryProperty+0x55 partmgr!PmFilterDeviceControl+0x15e partmgr!PmGlobalDispatch+0x101 nt!IofCallDriver+0xbe nt!IopSynchronousServiceTail+0x1c8 nt!IopXxxControlFile+0x940 nt!NtDeviceIoControlFile+0x5e nt!KiSystemServiceCopyEnd+0x25 ntdll!NtDeviceIoControlFile+0x14 KERNELBASE!DeviceIoControl+0x73 KERNEL32!DeviceIoControlImplementation+0x75 C__DiskSerialAPI!getFirstHddSerialNumber+0x181 Which is the same result that we achieved in part 1. As a result we copy storport.sys with its pdb an usie IDA to analyze it. As a result we copy storport.sys with its pdb an usie IDA to analyze it. To download the PDB, we use symchk.exe which usually can be found in the following path C:\\textbackslash Program Files (x86)\\textbackslash Windows Kits\\textbackslash 10\\textbackslash Debuggers\\textbackslash x64. So open CMD as administrator, go to the mentioned path with:\ncd C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64 Then simply copy storport.sys in C:\\textbackslash and execute the following command:\nsymchk.exe \"C:\\storport.sys\" /s SRV*C:\\*http://msdl.microsoft.com/download/symbols After that you will get PDB in the same location, just copy it alongside the driver and use IDA to analyze the functions.\nAs we mentioned before, Windows keeps tracking everything as Objects. We also mentioned that the function storport!RaGetUnitStorageDeviceProperty extracts data from a big struct called _RAID_UNIT_EXTENSION. Now the natural question is what is this struct and where does it belong to? The obvious answer to this question is, this structure is related to the Hard disks and it’s values initialized by Windows at boot time. To be able to see this object which passes the _RAID_UNIT_EXTENSION to storport.sys we have to look at the call stack and choose a good function to analyze it. After some search you will find out nt!IofCallDriver is the best candidate. It’s worth mentioning that WMIC is no longer available in 2024H2. To get all hard disks data you can use Windows PowerShell with the Get-Disk command.\nNow simply execute the compiled program again to hit the debug breakpoint. Then put a breakpoint on nt!NtDeviceIoControlFile with bp nt!NtDeviceIoControlFile and use g command to land on it. Then put a breakpoint on nt!IofCallDriver and disable the nt!NtDeviceIoControlFile break point simply using bl command to list all the breakpoints and clicking on disable. As we see in the call stack, the nt!IofCallDriver gets called 3 times. We want to land on the 3rd call. So just keep executing g command and tracking execution context with !process -1 0 till you land on the 3rd call. The nt!IofCallDriver definition is as below:\nNTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject, __drv_aliasesMem PIRP Irp); Thus by knowing the x64 ABI conventions of Windows, the value in RCX is the pointer to the passed Object. In my case that is RCX = 0xFFFF948DF615D050. By checking that address in memory you can see the Object.\nThe first two bytes with the value 0x3 show that we are in the correct location. Since this is the DEVICE_OBJECT and we should have CSHORT = 0x3. Now execute the following command to get offsets of DEVICE_OBJECT members for easier calculations:\ndt _DEVICE_OBJECT Thus to see _DEVOBJ_EXTENSION pointer we just have to check RCX+0x40 (0x40 is the offset of DeviceExtension) and check that location in memory. In my case that will be 0xFFFF948DF615D050 + 0x40. By checking this location in memory we see the following:\nPointers in x64 Operating systems are 8 bytes, and in Windows they are stored in reverse bytes. Thus in my case DeviceExtension = 0xFFFF948DF615D1A0. By checking this location, which looks like _RAID_UNIT_EXTENSION you will see the struct:\nKeep in mind, sometimes use a single step command like p to update Windbg values if you feel results are not okay. Sometimes Windbg freezes. The last remaining things for this Chapter is to verify the above data are indeed _RAID_UNIT_EXTENSION and to find out why RaGetUnitStorageDeviceProperty uses _RAID_UNIT_EXTENSION which has been answered already here. The first part is also easy, just put a breakpoint on storport!RaGetUnitStorageDeviceProperty and continue execution till you land on it. After that check RCX which points to the _RAID_UNIT_EXTENSION, compare this address to the previous address that we obtained above, they are the same.\nReimplementing spoofer n0Lin (@Alex3434) and btbd spoofer Most of the static spoofers are based on btbd and Alex3434 works. While these two are changing Disk Serials, it’s still traceable. And we have to mention that these two cause BSOD on the 24H2 build of Windows 11. We are trying to explain step by step how to rebuild a spoofer based on these two which works fine on 24H2. There is also work by SamuelTulach, which is a variant of some tools and uses Alex3434 static spoofer base code.\nLogic of implementation Now we are ready to explain the logic of spoofer, we are going to access the Disk kernel objects by searching the Device directory. We know that the name associated Objects are started by Raidport and followed by a number. After accessing the Object, We should modify the Serial Number of its extension. Now, to be able to find desired functions to implement our spoofer we just get ntoskrnl.exe PDB using SymChk.exe and use IDA.\nAfter that, since Drivers that are related to Hardware have a database in the registry(HardwareDatabase in _DRIVER_OBJECT struct), we have to update the registry by the modified structs. To do this we have to find an appropriate function in storport.sys, this is a trial and error game but in IDA we search Register keyword for function names we can see RaidUnitRegisterInterfaces is a good candidate to start with.\nUpdating SamuelTulach project Clone his project with the following command:\ngit clone --recurse-submodules https://github.com/SamuelTulach/mutante.git Configure the project to use C++20 and C17. To be able to see the kernel printing function in Windbg we have to take a few steps as well.\nThe component filter mask can be accessed in the registry key HKEY_LOCAL_MACHINE\\textbackslash SYSTEM\\textbackslash CurrentControlSet\\textbackslash Control\\textbackslash Session Manager\\textbackslash Debug Print Filter. Using a registry editor, create or open this key. Under this key, create a value with the name of the desired component, in uppercase. Set it equal to the DWORD value that you wish to use as the component filter mask[13].\nI created a DWORD called DEFAULT in the above path with the value 8. After that you have to restart the system. Please note that, after adding this registry key, you can’t use breakpoints in the normal way. For instance putting a breakpoint on some kernel functions might not work properly. So it is a good practice to export your key, delete it when you do not need it, and import it again when you need it for driver debugging. I exported my key in the project archive. In case you are too lazy to do it, you can just import it to your own registry key with the registry editor.\nHis source code for disk spoofing with my explanations are pretty much clear. However, two important parts need more explanation. The first important part is to use RAID_UNIT_EXTENSION in our code. This struct is huge and we only need a few parts of it in our code. To acces the strict simply execute below command in Windbg.\ndt storport!_RAID_UNIT_EXTENSION -b It is obvious that this struct might change in different builds of WIndows, and if that happens we might likely see a BSOD when using our spoofer. Thus we have to keep track of this struct. The things that we need are serial numbers in this struct. You simply find it in the output of Windbg and add it as a struct to your code. You will fill the parts that we do not need with normal bytes as char, if you need to add other parts in future to exported struct you need to calculate offset of places that you will fill with normal bytes. So the structure looks like this:\ntypedef struct _STOR_SCSI_IDENTITY { char Space[0x8]; // +0x008 SerialNumber : _STRING STRING SerialNumber; } STOR_SCSI_IDENTITY, * PSTOR_SCSI_IDENTITY; typedef struct _RAID_UNIT_EXTENSION { union { struct { char Space[0x70]; // +0x070 Identity _STOR_IDENTITY STOR_SCSI_IDENTITY Identity; } _Identity; }; } RAID_UNIT_EXTENSION, * PRAID_UNIT_EXTENSION; As you can see in the old project of SamuelTulach, the offset is not the same. In the older builds of windows this offset is 0x68 but in the current build at the writing time it is 0x70. Modify it accordingly.\nThe second part is the way that we call RaidUnitRegisterInterfaces from storport.sys. As you might know if we have the address of a function and know how many arguments it takes, you can call that function by address. In the SamuelTulach project, he finds the driver address in memory and finds the function offset by signature scanning. So we just borrow his codes to do the things. The other way to do this is, rebase the driver in IDA to zero and calculate the offset there, and use that offset in your code. You just have to get the storport.sys base in memory. To understand how you can call a function by its address I am going to explain it a little bit more. To do this we simply use function pointers, but before doing it you have to be comfortable reading C/C++ Declarations. To understand them more please read here and here. Now consider below example from here:\ntypedef int func(void); func* f = (func*)0xdeadbeef; int i = f(); We simply use typedef for declaration of a function that takes no argument and returns an int. Then using an alias, define a pointer to the function with the same declaration with its address (0xdeadbeef). Please notice that we can also use using from C++11. Like below:\nusing FuncPtr = int (*)(); FuncPtr f = (FuncPtr)0xdeadbeef; int i = f(); For example:\n#include using FuncPtr = int( * )(); int a() { return 1; } int b() { return 2; } int main() { std::cout \u003c\u003c \"The address of a function: \" \u003c\u003c (void * ) a \u003c\u003c std::endl; std::cout \u003c\u003c \"The address of b function: \" \u003c\u003c (void * ) b \u003c\u003c std::endl; unsigned long int Adr = (unsigned long int)(void * ) a; std::cout \u003c\u003c \"The value of Adr variable:0x\" \u003c\u003c std::hex \u003c\u003c Adr \u003c\u003c std::endl; FuncPtr g = a; int i = g(); std::cout \u003c\u003c i \u003c\u003c endl; g = b; i = g(); std::cout \u003c\u003c i \u003c\u003c endl; g = (int( * )())(Adr); i = g(); std::cout \u003c\u003c i \u003c\u003c std::endl; return 0; } Example output:\nThe address of a function: 0x562b7ca1b2d0 The address of b function: 0x562b7ca1b2e0 The value of Adr variable: 0x562b7ca1b2d0 1 2 1 Ofcourse the address of funtions wil can change at each execution, this is just an example. Thus to call the function one can use:\ntypedef __int64(__fastcall* RaidUnitRegisterInterfaces)(PRAID_UNIT_EXTENSION a1); Or:\nusing RaidUnitRegisterInterfaces = __int64 (__fastcall*)(PRAID_UNIT_EXTENSION a1); Now, you have to know for obvious reasons, Virtual Machines do not act like real physical hardware. As a result it’s better to always do serious testing on real physical hardware. Thus to test this spoofer, I tested it on physical hardware rather than virtual machines. Simply execute the driver with your preferred method, and then get the disk serials in Windows PowerShell with Get-Disk (WMIC is deprecated in 2024H2). After offset modification from 0x68 to 0x70 and execution of the driver you can see the disk serial spoofed on the latest build of WIndows at the time of writing.\nConclusion I hope this tutorial can help you in any way. The author is grateful for the great work of all the resources in this tutorial including a,b,c. Keep in mind, my main purpose never was to recreate spoofer from scratch nor to bypass any Anti-Cheat but to help understand Windows internals and storages a little bit better. Though I am really interested in working on Anti-Cheats, at the moment I do not have enough time for it. But surely I will try to make some tutorials about them in future as well. After all, it always seems impossible until it’s done.\nReferences https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/ ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/storage/device-unique-identifiers--duids--for-storage-devices ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-objectmanager ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-kernel-objects ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-driverobjects ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-names ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-directories ↩︎\nWindows Kernel Programming by Pavel Yosifovich ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-deviceobjects ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/types-of-wdm-device-objects ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree ↩︎\nhttps://learn.microsoft.com/en-us/sysinternals/downloads/winobj ↩︎\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-and-filteringdebugging-messages ↩︎\n","wordCount":"4520","inLanguage":"en","datePublished":"2024-10-22T19:01:18+03:30","dateModified":"2024-10-22T19:01:18+03:30","author":{"@type":"Person","name":"Exists4All"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_2/"},"publisher":{"@type":"Organization","name":"Exists4All","logo":{"@type":"ImageObject","url":"https://exists4all.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://exists4all.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://exists4all.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://exists4all.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://exists4all.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://exists4all.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://exists4all.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2</h1><div class=post-description>In this tutorial we are going to find out which Kernel APIs are used to get disk serials in WIndows 11 by reverse engineering the Windows Kernel. And then patching Kernel to assign random serial disks from ring 0.</div><div class=post-meta><span title='2024-10-22 19:01:18 +0330 +0330'>October 22, 2024</span>&nbsp;·&nbsp;4520 words&nbsp;·&nbsp;Exists4All&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Simple_Disk_Serial_Spoofer_part_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><blockquote><p>An author never does more damage to his readers than when he hides a difficulty. (Evariste Galois)</p></blockquote><p>You can download this tutorial and all necessary files in an archive file from <a href="https://drive.google.com/file/d/1Sx2_vBifq_EaJnWogqYSh8I0cIlZ1XBa/view?usp=drive_link">here</a>. The PDF version is also available <a href="https://drive.google.com/file/d/1mtm5t33TAIW7qvER8ooTwX5yeph4frI-/view?usp=drive_link">here</a>.</p><p>File password:</p><pre tabindex=0><code>exists4all.github.io
</code></pre><h1 id=table-of-contents>Table of Contents<a hidden class=anchor aria-hidden=true href=#table-of-contents>#</a></h1><ol><li><a href=#introduction>Introduction</a><ol><li><a href=#abstract>Abstract</a></li><li><a href=#required-tools>Required tools</a></li><li><a href=#required-knowledge>Required knowledge</a></li><li><a href=#purpose>Purpose</a></li></ol></li><li><a href=#windows-internal-and-hard-disks>Windows Internal and Hard disks</a><ol><li><a href=#device-unique-identifiers-duids-for-storage-devices>Device Unique Identifiers (DUIDs) for Storage Devices</a></li><li><a href=#looking-inside-kernel-architecture>Looking inside kernel architecture</a></li><li><a href=#find-hard-disks-objects-and-the-responsible-driver-that-gets-disk-serials>Find hard disks objects and The responsible driver that gets disk serials</a></li></ol></li><li><a href=#reimplementing-spoofer>Reimplementing spoofer</a><ol><li><a href=#n0lin-alex3434-and-btbd-spoofer>n0Lin (@Alex3434) and btbd spoofer</a></li><li><a href=#logic-of-implementation>Logic of implementation</a></li><li><a href=#updating-samueltulach-project>Updating SamuelTulach project</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li></ol><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><h3 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h3><p>After a long time being inactive I decided to finish my break due to some personal reasons. And one other reason was that it was getting closer to release date of Windows 24H2. After the release I noticed old spoofers cause problems and lead to BSOD so it&rsquo;s the best time to write a part 2 of the static spoofer tutorial. We are going to use amazing old work of other people to make our life simpler. We are basically going to do some reverse engineering and modify old spoofers to work on a new build of Windows and explain the philosophy of it. You can download most of the used resources and important files in this tutorial on my website. I also really appreciate any suggestion, and pointing out any errors since no one is prone to making mistakes. You can do that using <a href=https://forms.gle/Laggqs72A78JcBEx7>this</a> form.</p><h3 id=required-tools>Required tools<a hidden class=anchor aria-hidden=true href=#required-tools>#</a></h3><p>As usual, we are going to use the most used tools. I list them below.</p><ol><li>Windows 11 24H2</li><li>Visial Studio</li><li>Compatible SDK + WDK with Windows 11 24H2</li><li>Windbg Preview</li><li>Hyper-V with host OS</li><li>IDA</li><li>WinObj tool</li><li>An Intel CPU with Intel Virtualization Technology</li></ol><h3 id=required-knowledge>Required knowledge<a hidden class=anchor aria-hidden=true href=#required-knowledge>#</a></h3><p>Before starting, take a look at [Disk Serial Spoofer on Windows part <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>].</p><h3 id=purpose>Purpose<a hidden class=anchor aria-hidden=true href=#purpose>#</a></h3><p>In this tutorial we are mainly trying to analyze WIndows internals and learn about Hard disks more. These methods by no means are enough to bypass modern kernel anti cheats. There are lots of ways to track modifications and get DiskSerials later. For example Vanguard anti-cheat will start before most drivers and will track all the HWIDs before even spoofing them with these outdated methods. However, this is a good opportunity to learn the basics and develop more advanced spoofers by merging new methods and tools with it.</p><h2 id=windows-internal-and-hard-disks>Windows Internal and Hard disks<a hidden class=anchor aria-hidden=true href=#windows-internal-and-hard-disks>#</a></h2><h3 id=device-unique-identifiers-duids-for-storage-devices>Device Unique Identifiers (DUIDs) for Storage Devices<a hidden class=anchor aria-hidden=true href=#device-unique-identifiers-duids-for-storage-devices>#</a></h3><blockquote><p>Techniques to identify storage devices become inadequate as file system architecture becomes more complex, the number of operating system components multiplies, and initiators access storage targets through increasingly diverse hardware and software paths.<br>For example, the Plug and Play (PnP) manager generates an instance identifier (ID) for each device in the computer. Each instance ID corresponds to a single device node in the device tree and uniquely identifies a device, if the device remains in the same location. Instance IDs persist when a computer is restarted, but they do not remain the same if you move the device to a different bus or a different computer. As a result, instance IDs are inadequate for applications in storage area networks (SANs) and for some newer system components, such as the Windows Vista Diagnostic Service, that operate in environments with distributed storage. When a hard disk drive predicts a SMART failure, it generates an event for the diagnostic service. This event must contain an identifier that uniquely identifies the failing hard disk on all computers that the disk could be in and on all buses that it could be attached to. Instance IDs and any of the other device identification strings are inadequate for this purpose.<br>Some applications and system services, such as the Microsoft Cluster Service <strong>MSCS</strong> and the Partition Manager, use the device layout signature <strong>STORAGE_DEVICE_LAYOUT_SIGNATURE</strong> to uniquely identify a storage device in a cluster. But the device layout signature is inadequate for this purpose, under certain circumstances, and includes the following limitations:<br><strong>1. The signature might change or be cleared.</strong><br><strong>2. The signature might be unavailable if the device is not spinning or has problems accessing the sectors where the signature resides.</strong><br><strong>3. The signature is unavailable if the disk is reserved by another cluster node. MSCS can read the drive layout of only disks that are associated with the node that MSCS is running on. Software that must access disks in different cluster nodes must use an alternative to the disk layout signature.</strong><br><strong>4. Drive layout signatures cannot help distinguish between a logical unit number (LUN) and its snapshot. Because a LUN and its snapshot have identical content, their drive layout signatures will be the same.</strong><br>A serial number is sometimes a reliable technique of uniquely identifying a storage device that does not depend on the location of the device. The serial number is often available as a part of a device&rsquo;s inquiry data. Initiators can query for the inquiry data with a <strong>IOCTL_STORAGE_QUERY_PROPERTY</strong> request, and the port driver reports the results of the query in a <strong>STORAGE_DEVICE_DESCRIPTOR</strong> structure. However, this technique does not help identify devices, such as tape drives, that do not report inquiry data.[<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>]</p></blockquote><p>One can see now how serial numbers can be obtained by the last part of the referenced quote above.</p><h3 id=looking-inside-kernel-architecture>Looking inside kernel architecture<a hidden class=anchor aria-hidden=true href=#looking-inside-kernel-architecture>#</a></h3><p>As I mentioned before, <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/>Kernel-Mode Driver Architecture Design Guide</a> is a very important resource to study. The natural question before spoofing serial numbers is how windows actually get them when the system starts, to answer this question we have to go through the mentioned guide of Microsoft. Almost all of the following paragraphs are direct quotes from Microsoft.</p><p>Windows manages its own internal with Objects, thus we have multiple kinds of objects that windows use, among them we can name <strong>Device objects</strong>,<strong>Symbolic links</strong>,<strong>Registry keys</strong> and more. Each object has a header (containing information about the object such as its name, type, and location), and a body (containing data in a format determined by each type of object).[<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>][<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>]</p><blockquote><p>All the Internals of Windows are treated as Objects. Drivers are Object structures themselves that contain sub structures as well.</p></blockquote><p>The I/O manager creates a driver object for each driver that has been installed and loaded. Driver objects are defined using <strong>DRIVER_OBJECT</strong> structures. When the I/O manager calls a driver&rsquo;s DriverEntry routine, it supplies the address of the driver&rsquo;s driver object. The driver object contains storage for entry points to many of a driver&rsquo;s standard routines. The driver is responsible for filling in these entry points[<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>].</p><p>Kernel-mode objects are either named or unnamed and named objects are organized into a hierarchy. For example, <strong>\KernelObjects\LowMemoryCondition</strong> is the name of the standard event object that signals when the amount of free memory in the system is low. Drivers that create named objects do so in specific object directories[<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>].</p><blockquote><p>Each driver can create multiple objects and contain predefined objects as well which usually obey hierarchy. So there can be multiple objects that are related to a single Driver. Also there could be a single Object which is related to multiple Drivers.</p></blockquote><p>An object directory is a named object that is used solely to contain other named objects. For example, the <strong>\Device</strong> object directory contains the named device objects created by drivers. The following is a list of the top-level object directories that contain objects drivers might create or use:</p><ol><li><strong>\Callbacks</strong></li><li><strong>\Device</strong></li><li><strong>\KernelObjects</strong></li><li><strong>\DosDevices</strong></li></ol><p>Drivers can create new object directories by calling the <strong>ZwCreateDirectoryObject</strong> routine[<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>].</p><blockquote><p>Multiple Drivers can create different objects in the same directory. Directories help to maintain object oriented kernels.</p></blockquote><p>Object manager has to keep track of references, count them and maintain them, it also has to do the same for handles. Some anticheats for example can use the number of open handles to keep track of suspicious programs. The Object manager also destroys objects if they do not have any reference. To be able to see how the Object and Object directory work better you can use the WinObj tool, which we will do later to find hard disks[<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> p13-p15].</p><p>As we pointed out before, Drivers treated as objects. The defined structure for a driver Object is as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_DRIVER_OBJECT</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CSHORT</span> <span class=n>Type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CSHORT</span> <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDEVICE_OBJECT</span> <span class=n>DeviceObject</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>DriverStart</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>DriverSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>DriverSection</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_EXTENSION</span> <span class=n>DriverExtension</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>UNICODE_STRING</span> <span class=n>DriverName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PUNICODE_STRING</span> <span class=n>HardwareDatabase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PFAST_IO_DISPATCH</span> <span class=n>FastIoDispatch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_INITIALIZE</span> <span class=n>DriverInit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_STARTIO</span> <span class=n>DriverStartIo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_UNLOAD</span> <span class=n>DriverUnload</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_DISPATCH</span> <span class=n>MajorFunction</span><span class=p>[</span><span class=n>IRP_MJ_MAXIMUM_FUNCTION</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>DRIVER_OBJECT</span><span class=p>,</span> <span class=o>*</span> <span class=n>PDRIVER_OBJECT</span><span class=p>;</span>
</span></span></code></pre></div><p>It&rsquo;s clear now each Driver has at least one Device Object. The operating system represents devices by device objects. One or more device objects are associated with each device. Device objects serve as the target of all operations on the device. Kernel-mode drivers must create at least one device object for each device, with the few exceptions[<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>].</p><p>There are three kinds of WDM device objects:</p><ol><li>Physical Device Object (PDO) – represents a device on a bus to a bus driver.</li><li>Functional Device Object (FDO) – represents a device to a function driver.</li><li>Filter Device Object (filter DO) – represents a device to a filter driver[<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>].</li></ol><p>And finally the <strong>DEVICE_OBJECT</strong> struct is defined as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_DEVICE_OBJECT</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CSHORT</span> <span class=n>Type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USHORT</span> <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LONG</span> <span class=n>ReferenceCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_DRIVER_OBJECT</span> <span class=o>*</span> <span class=n>DriverObject</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_DEVICE_OBJECT</span> <span class=o>*</span> <span class=n>NextDevice</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_DEVICE_OBJECT</span> <span class=o>*</span> <span class=n>AttachedDevice</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_IRP</span> <span class=o>*</span> <span class=n>CurrentIrp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PIO_TIMER</span> <span class=n>Timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>Characteristics</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>__volatile</span> <span class=n>PVPB</span> <span class=n>Vpb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>DeviceExtension</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DEVICE_TYPE</span> <span class=n>DeviceType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CCHAR</span> <span class=n>StackSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LIST_ENTRY</span> <span class=n>ListEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>WAIT_CONTEXT_BLOCK</span> <span class=n>Wcb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>AlignmentRequirement</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>KDEVICE_QUEUE</span> <span class=n>DeviceQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>KDPC</span> <span class=n>Dpc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>ActiveThreadCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PSECURITY_DESCRIPTOR</span> <span class=n>SecurityDescriptor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>KEVENT</span> <span class=n>DeviceLock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USHORT</span> <span class=n>SectorSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USHORT</span> <span class=n>Spare1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>_DEVOBJ_EXTENSION</span> <span class=o>*</span> <span class=n>DeviceObjectExtension</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span> <span class=n>Reserved</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>DEVICE_OBJECT</span><span class=p>,</span> <span class=o>*</span> <span class=n>PDEVICE_OBJECT</span><span class=p>;</span>
</span></span></code></pre></div><p>The windows start identifying hardwares at the boot time and keep tracking them in an object, called Device tree. The PnP manager maintains a device tree that keeps track of the devices in the system. The following figure shows the device tree for a sample system configuration. The device tree contains information about the devices present on the system. The PnP manager builds this tree when the machine boots, using information from drivers and other components, and updates the tree as devices are added or removed. Each node of the device tree is called a device node, or devnode. A devnode consists of the device objects for the device&rsquo;s drivers, plus internal information maintained by the system. Therefore, there is a devnode for each device stack[<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>].</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_2/devtree.png alt=Image_1></p><blockquote><p>The PnP manager will find hard disks, and add them to the Device tree at boot time. It also keeps track of hardwares in case new hardware is added or unplugged.</p></blockquote><h3 id=find-hard-disks-objects-and-the-responsible-driver-that-gets-disk-serials>Find hard disks objects and The responsible driver that gets disk serials<a hidden class=anchor aria-hidden=true href=#find-hard-disks-objects-and-the-responsible-driver-that-gets-disk-serials>#</a></h3><p>To be able to see where the hard disk objects are, we use the WinObJ tool from sysinternals[<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>]. Simply download the tool and run it as administrator.</p><p>Simply download the tool and run it as administrator. As we mentioned before, <strong>\Device</strong> is one of the important object directories. Simply looking inside that directory you can see different kinds of identified hardwares there. In the picture of Device Tree you can see Hard disks are related to the <strong>SCSI</strong> port. Thus by searching the <strong>\Device</strong> directory you will be able to see symbolic links starting with the name <strong>ScsiPort</strong> name and then numbered in order. And there are actually Objects called <strong>RaidPort</strong> in the directory. So our job is to find and modify these Objects property.</p><p>As for the second part, which we explained in part 1 already, we just use a simple C++ code that gets a hard disk serial. Putting a breakpoint in the main function and keep debugging it using <strong>pc</strong> and <strong>t</strong> command till we reach a <strong>syscall</strong>. Then using the <strong>SSD table</strong> we find the kernel function that is going to be called and put a breakpoint on it. In part one I explain that after this you just have to keep using <strong>pc</strong> and <strong>t</strong> command till you find the function, however to make our own life easier, this time we are going to use script this time.</p><p>Simply boot up your Hyper-V and connect Windbg preview to it. If you do not know how to set these things up, read <a href=https://vimalshekar.github.io/reverse-engg/Kernel-Debugging-a-Hyper-V-VM>here</a> to setup Hyper-V and <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk>here</a> to set up WDK before installing Windbg Preview and after that install Windbg Preview. After that download <a href=https://gist.github.com/micjabbour/a2fbe50160862e6abe439c0b0769c3fb>this</a> C++ code, put <strong>__debugbreak()</strong> in the main and compile it. Then Move the compiled file into the VM and run it.</p><p>You can add the path of the source and PDB of the compiled file to the Windbg to be able to debug it by source. After running the file, the breakpoint will get hit, use <strong>!sym noisy</strong> and <strong>.reload</strong> command and then simply simply use <strong>pc</strong> and <strong>t</strong> command till you hit a <strong>syscall</strong>.</p><p>After hitting the syscall, we have to find which kernel function is going to be called using the SSD table. For more details about the SSD table read <a href=https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel>here</a>. I am just going to explain it in the cookie cutter format. First look at the <strong>RAX</strong> register value, in my case it is <strong>RAX=0x7</strong>. Next you have to execute the following command:</p><pre tabindex=0><code>dd nt!KiServiceTable+0xRAXValue*0x4 L1
</code></pre><p>So in my case it looks like that <strong>dd nt!KiServiceTable+0x7*0x4 L1</strong>, that will cause windbg return first value of table. In my case the result is <strong>fffff806`804d40bc 07b4bf06</strong>. Use the second value in the following command:</p><pre tabindex=0><code>u KiServiceTable + (0xReturnedValue&gt;&gt;4)
</code></pre><p>So in my case it looks like that <strong>u KiServiceTable + (0x7b4bf06&#187;4)</strong>. After that you will see the instructions like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>    <span class=nf>nt</span><span class=p>!</span><span class=no>NtDeviceIoControlFile</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88c90</span> <span class=mi>4883</span><span class=no>ec68</span>          <span class=no>sub</span>     <span class=no>rsp</span><span class=p>,</span><span class=mi>68</span><span class=no>h</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88c94</span> <span class=mi>8</span><span class=no>b8424b8000000</span>    <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>B8h</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88c9b</span> <span class=no>c744245800000000</span>  <span class=no>mov</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>58</span><span class=no>h</span><span class=p>],</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88ca3</span> <span class=no>c644245001</span>        <span class=no>mov</span>     <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>50</span><span class=no>h</span><span class=p>],</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88ca8</span> <span class=mi>89442448</span>          <span class=no>mov</span>     <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>48</span><span class=no>h</span><span class=p>],</span><span class=no>eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88cac</span> <span class=mi>488</span><span class=no>b8424b0000000</span>  <span class=no>mov</span>     <span class=no>rax</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>B0h</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88cb4</span> <span class=mi>4889442440</span>        <span class=no>mov</span>     <span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>40</span><span class=no>h</span><span class=p>],</span><span class=no>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>fffff806</span><span class=err>`</span><span class=mi>80</span><span class=no>c88cb9</span> <span class=mi>8</span><span class=no>b8424a8000000</span>    <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rsp</span><span class=err>+</span><span class=mi>0</span><span class=no>A8h</span><span class=p>]</span>
</span></span></code></pre></div><p>Now we just put a breakpoint on this kernel function with this <strong>bp nt!NtDeviceIoControlFile</strong>. Then hit <strong>g</strong> command to continue execution. Keep in mind after each hit, we have to check execution context to be sure that this breakpoint that we landed on is related to our program with this command <strong>!process -1 0</strong>. After you confirm the landing breakpoint is for our program disable it. Then we need to use a script to execute <strong>t</strong> and <strong>pc</strong> commands automatically many times so we don&rsquo;t have to do it manually. To do this we create a file named <strong>Script.js</strong> and paste the following code in it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>invokeScript</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>ctl</span> <span class=o>=</span> <span class=nx>host</span><span class=p>.</span><span class=nx>namespace</span><span class=p>.</span><span class=nx>Debugger</span><span class=p>.</span><span class=nx>Utility</span><span class=p>.</span><span class=nx>Control</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>output</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kd>var</span> <span class=nx>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mi>20</span><span class=p>;</span> <span class=nx>i</span><span class=o>+=</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>output</span> <span class=o>=</span> <span class=nx>ctl</span><span class=p>.</span><span class=nx>ExecuteCommand</span><span class=p>(</span><span class=s2>&#34;pc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>host</span><span class=p>.</span><span class=nx>diagnostics</span><span class=p>.</span><span class=nx>debugLog</span><span class=p>(</span><span class=s2>&#34;  &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=s2>&#34;\n&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>output</span> <span class=o>=</span> <span class=nx>ctl</span><span class=p>.</span><span class=nx>ExecuteCommand</span><span class=p>(</span><span class=s2>&#34;t&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nx>host</span><span class=p>.</span><span class=nx>diagnostics</span><span class=p>.</span><span class=nx>debugLog</span><span class=p>(</span><span class=s2>&#34;  &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;\n&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>To learn more about scripting you can read <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/javascript-debugger-scripting>here</a>. No simply running the script with <strong>.scriptrun ScriptPath\textbackslash Script.js</strong>, Where <strong>ScriptPath</strong> should point to the absolute location of the script. After each execution of this script, we have to check <strong>stack call</strong> to see interesting functions. Then based on our experience we use t and pc commands manually to slowly observe what will happen. This script is just used to get rid of lot’s of obvious executions in the early stages. Keep in mind there might be BSOD happening a few times. So you just have to start all over again if that happens. If the script is stuck, pausing and unpausing the Hyper-V can help sometimes. After 4 times script execution and a few manual execution commands I arrived at the following calls:</p><pre tabindex=0><code>    storport!RaGetUnitStorageDeviceProperty+0x4d
    storport!RaUnitStorageQueryPropertyIoctl+0x172
    storport!RaUnitDeviceControlIrp+0x19d
    storport!RaDriverDeviceControlIrp+0x8c
    nt!IofCallDriver+0xbe
    CLASSPNP!ClassDeviceControl+0x51a
    disk!DiskDeviceControl+0xf4
    CLASSPNP!ClassDeviceControlDispatch+0x91
    CLASSPNP!ClassGlobalDispatch+0x3a
    nt!IofCallDriver+0xbe
    partmgr!PmIoctlQueryProperty+0x55
    partmgr!PmFilterDeviceControl+0x15e
    partmgr!PmGlobalDispatch+0x101
    nt!IofCallDriver+0xbe
    nt!IopSynchronousServiceTail+0x1c8
    nt!IopXxxControlFile+0x940
    nt!NtDeviceIoControlFile+0x5e
    nt!KiSystemServiceCopyEnd+0x25
    ntdll!NtDeviceIoControlFile+0x14
    KERNELBASE!DeviceIoControl+0x73
    KERNEL32!DeviceIoControlImplementation+0x75
    C__DiskSerialAPI!getFirstHddSerialNumber+0x181
</code></pre><p>Which is the same result that we achieved in part 1. As a result we copy <strong>storport.sys</strong> with its pdb an usie IDA to analyze it. As a result we copy storport.sys with its pdb an usie IDA to analyze it. To download the PDB, we use <strong>symchk.exe</strong> which usually can be found in the following path <strong>C:\textbackslash Program Files (x86)\textbackslash Windows Kits\textbackslash 10\textbackslash Debuggers\textbackslash x64</strong>. So open CMD as administrator, go to the mentioned path with:</p><pre tabindex=0><code>cd C:\Program Files (x86)\Windows Kits\10\Debuggers\x64
</code></pre><p>Then simply copy <strong>storport.sys</strong> in <strong>C:\textbackslash</strong> and execute the following command:</p><pre tabindex=0><code>symchk.exe &#34;C:\storport.sys&#34; /s SRV*C:\*http://msdl.microsoft.com/download/symbols
</code></pre><p>After that you will get PDB in the same location, just copy it alongside the driver and use IDA to analyze the functions.</p><p>As we mentioned before, Windows keeps tracking everything as Objects. We also mentioned that the function <strong>storport!RaGetUnitStorageDeviceProperty</strong> extracts data from a big struct called <strong>_RAID_UNIT_EXTENSION</strong>. Now the natural question is what is this struct and where does it belong to?
The obvious answer to this question is, this structure is related to the Hard disks and it&rsquo;s values initialized by Windows at boot time. To be able to see this object which passes the <strong>_RAID_UNIT_EXTENSION</strong> to <strong>storport.sys</strong> we have to look at the call stack and choose a good function to analyze it. After some search you will find out <strong>nt!IofCallDriver</strong> is the best candidate. It’s worth mentioning that <strong>WMIC</strong> is no longer available in 2024H2. To get all hard disks data you can use <strong>Windows PowerShell</strong> with the <strong>Get-Disk</strong> command.</p><p>Now simply execute the compiled program again to hit the debug breakpoint. Then put a breakpoint on <strong>nt!NtDeviceIoControlFile</strong> with <strong>bp nt!NtDeviceIoControlFile</strong> and use <strong>g</strong> command to land on it. Then put a breakpoint on <strong>nt!IofCallDriver</strong> and disable the <strong>nt!NtDeviceIoControlFile</strong> break point simply using <strong>bl</strong> command to list all the breakpoints and clicking on <strong>disable</strong>. As we see in the call stack, the <strong>nt!IofCallDriver</strong> gets called 3 times. We want to land on the 3rd call. So just keep executing <strong>g</strong> command and tracking execution context with <strong>!process -1 0</strong> till you land on the 3rd call. The <strong>nt!IofCallDriver</strong> definition is as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=n>NTSTATUS</span> <span class=nf>IofCallDriver</span><span class=p>(</span><span class=n>PDEVICE_OBJECT</span>    <span class=n>DeviceObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>__drv_aliasesMem</span> <span class=n>PIRP</span>  <span class=n>Irp</span><span class=p>);</span>
</span></span></code></pre></div><p>Thus by knowing the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170#x64-calling-conventions">x64 ABI conventions of Windows</a>, the value in <strong>RCX</strong> is the pointer to the passed Object. In my case that is <strong>RCX = 0xFFFF948DF615D050</strong>. By checking that address in memory you can see the Object.</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_2/ObjInMem.png alt=Image_2></p><p>The first two bytes with the value <strong>0x3</strong> show that we are in the correct location. Since this is the <strong>DEVICE_OBJECT</strong> and we should have <strong>CSHORT = 0x3</strong>. Now execute the following command to get offsets of <strong>DEVICE_OBJECT</strong> members for easier calculations:</p><pre tabindex=0><code>dt _DEVICE_OBJECT
</code></pre><p>Thus to see <strong>_DEVOBJ_EXTENSION</strong> pointer we just have to check <strong>RCX+0x40</strong> (<strong>0x40</strong> is the offset of <strong>DeviceExtension</strong>) and check that location in memory. In my case that will be <strong>0xFFFF948DF615D050 + 0x40</strong>. By checking this location in memory we see the following:</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_2/PtoDeviceExtension.png alt=Image_3></p><p>Pointers in x64 Operating systems are 8 bytes, and in Windows they are stored in reverse bytes. Thus in my case <strong>DeviceExtension = 0xFFFF948DF615D1A0</strong>. By checking this location, which looks like <strong>_RAID_UNIT_EXTENSION</strong> you will see the struct:</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_2/DiskSerial.png alt=Image_4></p><p>Keep in mind, sometimes use a single step command like <strong>p</strong> to update Windbg values if you feel results are not okay. Sometimes Windbg freezes. The last remaining things for this Chapter is to verify the above data are indeed <strong>_RAID_UNIT_EXTENSION</strong> and to find out why <strong>RaGetUnitStorageDeviceProperty</strong> uses <strong>_RAID_UNIT_EXTENSION</strong> which has been answered already <a href=https://reverseengineering.stackexchange.com/questions/30897/find-out-which-struct-ragetunitstoragedeviceproperty-use-by-reverse-engineering>here</a>. The first part is also easy, just put a breakpoint on <strong>storport!RaGetUnitStorageDeviceProperty</strong> and continue execution till you land on it. After that check <strong>RCX</strong> which points to the <strong>_RAID_UNIT_EXTENSION</strong>, compare this address to the previous address that we obtained above, they are the same.</p><h2 id=reimplementing-spoofer>Reimplementing spoofer<a hidden class=anchor aria-hidden=true href=#reimplementing-spoofer>#</a></h2><h3 id=n0lin-alex3434-and-btbd-spoofer>n0Lin (@Alex3434) and btbd spoofer<a hidden class=anchor aria-hidden=true href=#n0lin-alex3434-and-btbd-spoofer>#</a></h3><p>Most of the static spoofers are based on <a href=https://github.com/btbd/hwid>btbd</a> and <a href=https://github.com/Alex3434/wmi-static-spoofer>Alex3434</a> works. While these two are changing Disk Serials, it’s still traceable. And we have to mention that these two cause BSOD on the 24H2 build of Windows 11. We are trying to explain step by step how to rebuild a spoofer based on these two which works fine on 24H2. There is also work by <a href=https://github.com/SamuelTulach/mutante>SamuelTulach</a>, which is a variant of some tools and uses Alex3434 static spoofer base code.</p><h2 id=logic-of-implementation>Logic of implementation<a hidden class=anchor aria-hidden=true href=#logic-of-implementation>#</a></h2><p>Now we are ready to explain the logic of spoofer, we are going to access the Disk kernel objects by searching the <strong>Device</strong> directory. We know that the name associated Objects are started by <strong>Raidport</strong> and followed by a number. After accessing the Object, We should modify the Serial Number of its extension. Now, to be able to find desired functions to implement our spoofer we just get <strong>ntoskrnl.exe</strong> PDB using <strong>SymChk.exe</strong> and use IDA.</p><p>After that, since Drivers that are related to Hardware have a database in the registry(<strong>HardwareDatabase</strong> in <strong>_DRIVER_OBJECT</strong> struct), we have to update the registry by the modified structs. To do this we have to find an appropriate function in <strong>storport.sys</strong>, this is a trial and error game but in IDA we search Register keyword for function names we can see <strong>RaidUnitRegisterInterfaces</strong> is a good candidate to start with.</p><h2 id=updating-samueltulach-project>Updating SamuelTulach project<a hidden class=anchor aria-hidden=true href=#updating-samueltulach-project>#</a></h2><p>Clone his project with the following command:</p><pre tabindex=0><code>git clone --recurse-submodules https://github.com/SamuelTulach/mutante.git
</code></pre><p>Configure the project to use C++20 and C17. To be able to see the kernel printing function in Windbg we have to take a few steps as well.</p><blockquote><p>The component filter mask can be accessed in the registry key <strong>HKEY_LOCAL_MACHINE\textbackslash SYSTEM\textbackslash CurrentControlSet\textbackslash Control\textbackslash Session Manager\textbackslash Debug Print Filter</strong>. Using a registry editor, create or open this key. Under this key, create a value with the name of the desired component, in uppercase. Set it equal to the <strong>DWORD</strong> value that you wish to use as the component filter mask[<sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup>].</p></blockquote><p>I created a <strong>DWORD</strong> called <strong>DEFAULT</strong> in the above path with the value <strong>8</strong>. After that you have to restart the system. <strong>Please note that, after adding this registry key, you can’t use breakpoints in the normal way. For instance putting a breakpoint on some kernel functions might not work properly. So it is a good practice to export your key, delete it when you do not need it, and import it again when you need it for driver debugging</strong>. I exported my key in the project archive. In case you are too lazy to do it, you can just import it to your own registry key with the registry editor.</p><p>His source code for disk spoofing with my explanations are pretty much clear. However, two important parts need more explanation. The first important part is to use <strong>RAID_UNIT_EXTENSION</strong> in our code. This struct is huge and we only need a few parts of it in our code. To acces the strict simply execute below command in <strong>Windbg</strong>.</p><pre tabindex=0><code>dt storport!_RAID_UNIT_EXTENSION -b
</code></pre><p>It is obvious that this struct might change in different builds of WIndows, and if that happens we might likely see a BSOD when using our spoofer. Thus we have to keep track of this struct. The things that we need are serial numbers in this struct. You simply find it in the output of Windbg and add it as a struct to your code. You will fill the parts that we do not need with normal bytes as char, if you need to add other parts in future to exported struct you need to calculate offset of places that you will fill with normal bytes. So the structure looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_STOR_SCSI_IDENTITY</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>Space</span><span class=p>[</span><span class=mh>0x8</span><span class=p>];</span> <span class=c1>// +0x008 SerialNumber     : _STRING
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>STRING</span> <span class=n>SerialNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>STOR_SCSI_IDENTITY</span><span class=p>,</span> <span class=o>*</span> <span class=n>PSTOR_SCSI_IDENTITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_RAID_UNIT_EXTENSION</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>struct</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>char</span> <span class=n>Space</span><span class=p>[</span><span class=mh>0x70</span><span class=p>];</span> <span class=c1>// +0x070 Identity         _STOR_IDENTITY
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>STOR_SCSI_IDENTITY</span> <span class=n>Identity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=n>_Identity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>RAID_UNIT_EXTENSION</span><span class=p>,</span> <span class=o>*</span> <span class=n>PRAID_UNIT_EXTENSION</span><span class=p>;</span>
</span></span></code></pre></div><p>As you can see in the old project of <a href=https://github.com/SamuelTulach/mutante>SamuelTulach</a>, the offset is not the same. In the older builds of windows this offset is <strong>0x68</strong> but in the current build at the writing time it is <strong>0x70</strong>. Modify it accordingly.</p><p>The second part is the way that we call <strong>RaidUnitRegisterInterfaces</strong> from <strong>storport.sys</strong>. As you might know if we have the address of a function and know how many arguments it takes, you can call that function by address. In the <a href=https://github.com/SamuelTulach/mutante>SamuelTulach</a> project, he finds the driver address in memory and finds the function offset by signature scanning. So we just borrow his codes to do the things. The other way to do this is, rebase the driver in IDA to zero and calculate the offset there, and use that offset in your code. You just have to get the <strong>storport.sys</strong> base in memory. To understand how you can call a function by its address I am going to explain it a little bit more. To do this we simply use function pointers, but before doing it you have to be comfortable reading C/C++ Declarations. To understand them more please read <a href=https://parrt.cs.usfca.edu/doc/how-to-read-C-declarations.html>here</a> and <a href=https://riptutorial.com/c/example/18833/using-the-right-left-or-spiral-rule-to-decipher-c-declaration>here</a>. Now consider below example from <a href=https://stackoverflow.com/questions/4295432/typedef-function-pointer>here</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=k>typedef</span> <span class=kt>int</span> <span class=nf>func</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=o>*</span> <span class=n>f</span> <span class=o>=</span> <span class=p>(</span><span class=n>func</span><span class=o>*</span><span class=p>)</span><span class=mh>0xdeadbeef</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>f</span><span class=p>();</span>
</span></span></code></pre></div><p>We simply use <strong>typedef</strong> for declaration of a function that takes no argument and returns an int. Then using an alias, define a pointer to the function with the same declaration with its address (<strong>0xdeadbeef</strong>). Please notice that we can also use <strong>using</strong> from C++11. Like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=k>using</span> <span class=n>FuncPtr</span> <span class=o>=</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>)();</span>
</span></span><span class=line><span class=cl>    <span class=n>FuncPtr</span> <span class=n>f</span> <span class=o>=</span> <span class=p>(</span><span class=n>FuncPtr</span><span class=p>)</span><span class=mh>0xdeadbeef</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>f</span><span class=p>();</span>
</span></span></code></pre></div><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>    <span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>using</span> <span class=n>FuncPtr</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span> <span class=o>*</span> <span class=p>)();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>a</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>b</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The address of a function: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The address of b function: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>Adr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The value of Adr variable:0x&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>hex</span> <span class=o>&lt;&lt;</span> <span class=n>Adr</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>FuncPtr</span> <span class=n>g</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>g</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>g</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>=</span> <span class=n>g</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>g</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>(</span> <span class=o>*</span> <span class=p>)())(</span><span class=n>Adr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>=</span> <span class=n>g</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>Example output:</p><pre tabindex=0><code>    The address of a function: 0x562b7ca1b2d0
    The address of b function: 0x562b7ca1b2e0
    The value of Adr variable: 0x562b7ca1b2d0
    1
    2
    1
</code></pre><p>Ofcourse the address of funtions wil can change at each execution, this is just an example. Thus to call the function one can use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>__int64</span><span class=p>(</span><span class=kr>__fastcall</span><span class=o>*</span> <span class=n>RaidUnitRegisterInterfaces</span><span class=p>)(</span><span class=n>PRAID_UNIT_EXTENSION</span> <span class=n>a1</span><span class=p>);</span>
</span></span></code></pre></div><p>Or:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>using</span> <span class=n>RaidUnitRegisterInterfaces</span> <span class=o>=</span> <span class=kr>__int64</span> <span class=p>(</span><span class=kr>__fastcall</span><span class=o>*</span><span class=p>)(</span><span class=n>PRAID_UNIT_EXTENSION</span> <span class=n>a1</span><span class=p>);</span>
</span></span></code></pre></div><p>Now, you have to know for obvious reasons, Virtual Machines do not act like real physical hardware. As a result it&rsquo;s better to always do serious testing on real physical hardware. Thus to test this spoofer, I tested it on physical hardware rather than virtual machines. Simply execute the driver with your preferred method, and then get the disk serials in <strong>Windows PowerShell</strong> with <strong>Get-Disk</strong> (<strong>WMIC</strong> is deprecated in <strong>2024H2</strong>). After offset modification from <strong>0x68</strong> to <strong>0x70</strong> and execution of the driver you can see the disk serial spoofed on the latest build of WIndows at the time of writing.</p><p><img loading=lazy src=/Simple_Disk_Serial_Spoofer_part_2/SpoofedDisk.png alt=Image_5></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope this tutorial can help you in any way. The author is grateful for the great work of all the resources in this tutorial including a,b,c. Keep in mind, my main purpose never was to recreate spoofer from scratch nor to bypass any Anti-Cheat but to help understand Windows internals and storages a little bit better. Though I am really interested in working on Anti-Cheats, at the moment I do not have enough time for it. But surely I will try to make some tutorials about them in future as well. After all, it always seems impossible until it&rsquo;s done.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/>https://exists4all.github.io/posts/simple_disk_serial_spoofer_part_1/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/device-unique-identifiers--duids--for-storage-devices>https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/device-unique-identifiers--duids--for-storage-devices</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-objectmanager>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-objectmanager</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-kernel-objects>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-kernel-objects</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-driverobjects>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-driverobjects</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-names>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-names</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-directories>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/object-directories</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>Windows Kernel Programming by Pavel Yosifovich&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-deviceobjects>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-deviceobjects</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/types-of-wdm-device-objects>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/types-of-wdm-device-objects</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree>https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p><a href=https://learn.microsoft.com/en-us/sysinternals/downloads/winobj>https://learn.microsoft.com/en-us/sysinternals/downloads/winobj</a>&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-and-filteringdebugging-messages>https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-and-filteringdebugging-messages</a>&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://exists4all.github.io/tags/vmware/>VMware</a></li><li><a href=https://exists4all.github.io/tags/windows-kernel-development/>Windows Kernel Development</a></li><li><a href=https://exists4all.github.io/tags/ntoskrnl/>Ntoskrnl</a></li><li><a href=https://exists4all.github.io/tags/harddisk-serial-spoofing/>Harddisk Serial Spoofing</a></li><li><a href=https://exists4all.github.io/tags/kernel-spoofer/>Kernel Spoofer</a></li><li><a href=https://exists4all.github.io/tags/windows-internals/>Windows Internals</a></li></ul><nav class=paginav><a class=next href=https://exists4all.github.io/posts/simpepecrypter/><span class=title>Next »</span><br><span>How to create your own PE Crypter with C++ from scratch</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on x" href="https://x.com/intent/tweet/?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f&amp;hashtags=VMware%2cWindowskerneldevelopment%2cntoskrnl%2cHarddiskserialspoofing%2cKernelspoofer%2cWindowsInternals"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f&amp;title=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202&amp;summary=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202&amp;source=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f&title=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202%20-%20https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on telegram" href="https://telegram.me/share/url?text=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202&amp;url=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to make your own Simple Kernel static Disk Serial Spoofer on Windows part 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20to%20make%20your%20own%20Simple%20Kernel%20static%20Disk%20Serial%20Spoofer%20on%20Windows%20part%202&u=https%3a%2f%2fexists4all.github.io%2fposts%2fsimple_disk_serial_spoofer_part_2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://exists4all.github.io/>Exists4All</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>